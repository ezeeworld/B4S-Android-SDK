{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome Neerby SDK Android\n\n\nFor more details about the project visit \nNeer.by", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-neerby-sdk-android", 
            "text": "For more details about the project visit  Neer.by", 
            "title": "Welcome Neerby SDK Android"
        }, 
        {
            "location": "/include_in_project/", 
            "text": "Hardware \n software requirements\n\n\nThe Neerby SDK uses Bluetooth 4.0 BLE (Bluetooth Low Energy) and thus is only available on the devices running  \nAndroid 4.3\n, API level 18. \n\n\nAs Android 4.3 introduced support for Bluetooth LE, API level 18 is the minimum API level requirement for the SDK to work with beacons. However, it is safe to include the library in an application that support older Android versions. Since SDK 1.8.3 the minimum target is API level 10. If you need an even lower SDK, you can simply have Gradle ignore the B4S minimum SDK level by adding to your \nAndroidManifest.xml\n:\n\n\n  \nuses-sdk tools:overrideLibrary=\ncom.ezeeworld.b4s.android.sdk, com.ezeeworld.b4s.android.sdk.playservices\n /\n\n\n\n\n\nInstallation\n\n\nYou must perform the following tasks to integrate the Neerby SDK with your application:\n\n\n\n\nGet your application ID\n\n\nImport required librairies manually or using \nMaven\n\n\nAdapt your \n.gradle\n files\n\n\nCode-level integration\n\n\n\n\nGet your application ID\n\n\nIn order to use the SDK you must know the application ID that is tied to your Neerby account. \n\n\n\n\nGo to \nNeerby Web Manager\n\n\nLog-in with your Neerby account\n\n\nGo to the \"Applications\" section\n\n\nSelect your application ID\n\n\n\n\nManual installation\n\n\nThe SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root \nbuild.gradle\n file you should have a \nrepositories\n element, to which the plain libraries directory should be added, typically called \nlibs\n:\n\n\nallprojects {\n    repositories {\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}\n\n\n\n\nSee \nthe \nsample-gradle\n root project's \nbuild.gradle\n file\n for an example of this repository declaration.\n\n\nNext, add all the B4S dependencies and reference its .AAR files in the main application's \napp/build.gradle\n file:\n\n\ndependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:9.8.0'\n    compile 'com.google.android.gms:play-services-ads:9.8.0'\n    compile 'com.google.android.gms:play-services-gcm:9.8.0'\n    compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices9.80', ext:'aar')\n}\n\n\n\n\nImportant\n: This example relies on the Play Services version 9.8.0, but the SDK is compatible with all versions of the Play Services. Simply refer to the desired \nplay-services-xxx\n libraries as usual and select the corresponding \nb4s-android-sdk-playservicesXXX.aar\n file. For example, if the Play Services 6.5 (v22) should be used instead:\n\n\n    ...\n    compile 'com.google.android.gms:play-services-location:6.5.87'\n    compile 'com.google.android.gms:play-services-ads:6.5.87'\n    ...\n    compile (name:'b4s-android-sdk-playservices650', ext:'aar')\n\n\n\n\nThe Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the \nbuildTypes\n part of your Gradle file a \npackagingOptions\n element to include the license files:\n\n\n    buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }\n\n\n\n\nSee \nthe \nsample-gradle\n app module's \napp/build.gradle\n file\n for an example, including all the dependencies.\n\n\nFinally, copy the \nb4s-android-sdk.aar\n and the \nb4s-android-sdk-playservicesXXX.aar\n version of your choice from the \n/sdk/aar\n release directory\n to your \napp/libs\n directory.\n\n\nInstallation using Maven\n\n\nTo simplify your integration you can use \nMaven\n\n\nThe SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root \nbuild.gradle\n file you should have a \nrepositories\n element, to which our Maven repository should be added:the plain libraries directory should be added:\n\n\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \nhttp://maven.ezeeworld.com:8081/artifactory/libs-release-local\n }\n    }\n}\n\n\n\n\nNext, add all the B4S dependencies and reference its .AAR files in the main application's \napp/build.gradle\n file:\n\n\ndependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:9.8.0'\n    compile 'com.google.android.gms:play-services-ads:9.8.0'\n    compile 'com.google.android.gms:play-services-gcm:9.8.0'\n    compile 'by.neer.sdk:nby-playservices-support980:2.2.1@aar'\n    compile 'by.neer.sdk:nby-sdk:2.2.1@aar'\n}\n\n\n\n\nThe Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the \nbuildTypes\n part of your Gradle file a \npackagingOptions\n element to include the license files:\n\n\n    buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }", 
            "title": "Include the SDK in your project"
        }, 
        {
            "location": "/include_in_project/#hardware-software-requirements", 
            "text": "The Neerby SDK uses Bluetooth 4.0 BLE (Bluetooth Low Energy) and thus is only available on the devices running   Android 4.3 , API level 18.   As Android 4.3 introduced support for Bluetooth LE, API level 18 is the minimum API level requirement for the SDK to work with beacons. However, it is safe to include the library in an application that support older Android versions. Since SDK 1.8.3 the minimum target is API level 10. If you need an even lower SDK, you can simply have Gradle ignore the B4S minimum SDK level by adding to your  AndroidManifest.xml :     uses-sdk tools:overrideLibrary= com.ezeeworld.b4s.android.sdk, com.ezeeworld.b4s.android.sdk.playservices  /", 
            "title": "Hardware &amp; software requirements"
        }, 
        {
            "location": "/include_in_project/#installation", 
            "text": "You must perform the following tasks to integrate the Neerby SDK with your application:   Get your application ID  Import required librairies manually or using  Maven  Adapt your  .gradle  files  Code-level integration", 
            "title": "Installation"
        }, 
        {
            "location": "/include_in_project/#get-your-application-id", 
            "text": "In order to use the SDK you must know the application ID that is tied to your Neerby account.    Go to  Neerby Web Manager  Log-in with your Neerby account  Go to the \"Applications\" section  Select your application ID", 
            "title": "Get your application ID"
        }, 
        {
            "location": "/include_in_project/#manual-installation", 
            "text": "The SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root  build.gradle  file you should have a  repositories  element, to which the plain libraries directory should be added, typically called  libs :  allprojects {\n    repositories {\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}  See  the  sample-gradle  root project's  build.gradle  file  for an example of this repository declaration.  Next, add all the B4S dependencies and reference its .AAR files in the main application's  app/build.gradle  file:  dependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:9.8.0'\n    compile 'com.google.android.gms:play-services-ads:9.8.0'\n    compile 'com.google.android.gms:play-services-gcm:9.8.0'\n    compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices9.80', ext:'aar')\n}  Important : This example relies on the Play Services version 9.8.0, but the SDK is compatible with all versions of the Play Services. Simply refer to the desired  play-services-xxx  libraries as usual and select the corresponding  b4s-android-sdk-playservicesXXX.aar  file. For example, if the Play Services 6.5 (v22) should be used instead:      ...\n    compile 'com.google.android.gms:play-services-location:6.5.87'\n    compile 'com.google.android.gms:play-services-ads:6.5.87'\n    ...\n    compile (name:'b4s-android-sdk-playservices650', ext:'aar')  The Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the  buildTypes  part of your Gradle file a  packagingOptions  element to include the license files:      buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }  See  the  sample-gradle  app module's  app/build.gradle  file  for an example, including all the dependencies.  Finally, copy the  b4s-android-sdk.aar  and the  b4s-android-sdk-playservicesXXX.aar  version of your choice from the  /sdk/aar  release directory  to your  app/libs  directory.", 
            "title": "Manual installation"
        }, 
        {
            "location": "/include_in_project/#installation-using-maven", 
            "text": "To simplify your integration you can use  Maven  The SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root  build.gradle  file you should have a  repositories  element, to which our Maven repository should be added:the plain libraries directory should be added:  allprojects {\n    repositories {\n        jcenter()\n        maven { url  http://maven.ezeeworld.com:8081/artifactory/libs-release-local  }\n    }\n}  Next, add all the B4S dependencies and reference its .AAR files in the main application's  app/build.gradle  file:  dependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:9.8.0'\n    compile 'com.google.android.gms:play-services-ads:9.8.0'\n    compile 'com.google.android.gms:play-services-gcm:9.8.0'\n    compile 'by.neer.sdk:nby-playservices-support980:2.2.1@aar'\n    compile 'by.neer.sdk:nby-sdk:2.2.1@aar'\n}  The Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the  buildTypes  part of your Gradle file a  packagingOptions  element to include the license files:      buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }", 
            "title": "Installation using Maven"
        }, 
        {
            "location": "/using_the_sdk/", 
            "text": "Depending on how you use the Neerby SDK, some steps are mandatory, some are optional.\n\n\n\n\nBase integration for counting visits\n\n\nRecording user data\n\n\nBeacon-based notifications\n\n\nApplication tagging\n\n\nPush notifications\n\n\n\n\nBase integration\n\n\nAdd the \nApplication ID\n provided by Ezeeworld to the \nApplication\n object in you \nAndroidManifest.xml\n. Depending on your project configuration you might have to create this object\n\n\napplication\n   android:name=\ncom.ezeeworld.b4s.android.sdk.sample.SampleApp\n\n   android:label=\n@string/app_name\n \n\n   ...\n   \nmeta-data android:name=\nby.neer.sdk.APP_ID\n android:value=\nMY-APP-ID\n /\n\n   ...\n\n/application\n\n\n\n\n\nAnd replace \nMY-APP-ID\n with your unique application ID.\n\n\nImport the SDK in your Application subclass:\n\n\nimport com.ezeeworld.b4s.android.sdk.B4SSettings;\nimport com.ezeeworld.b4s.android.sdk.monitor.MonitoringManager;\n\n\n\n\nStart the SDK in the \nonCreate\n method:\n\n\nB4SSettings settings = B4SSettings.init(this);\nMonitoringManager.ensureMonitoringService(this);\n\n\n\n\nPrevent your application to trigger notifications resulting of mock locations\n\n\nOn Android, some applications (like Lockito) can generate mock locations (typically for debuging purpose). By default, mock locations are authorised by the Neer.by SDK. You can disable them with the following code :\n\n\nB4SSettings.get().setDiscardMockLocations(true);\n\n\n\n\nRecording user data\n\n\nNeerby can relate events to individual customers. Supplying the customer details is typically done on startup and/or after a user signed in to his/her account. In these cases you can update te SDK with this customer data (which is persisted; no need to call this every time). The key should use reverse-dns-like notation to be used as a domain. For instance, the user hometown should use a \"user.hometown\" key. A few keys are provided (Firstname, lastname, gender...)\n\n\nB4SUserProperty.get().store(B4SUserProperty.USER_FIRST_NAME, \nJean-Michel\n);\nB4SUserProperty.get().store(B4SUserProperty.USER_LAST_NAME, \nB\u00e9catresse\n);\nB4SUserProperty.get().store(B4SUserProperty.USER_GENDER, B4SUserProperty.Gender.Male);\nB4SUserProperty.get().store(\nuser.hometown\n, \nTubbydome\n);\n\n\n\n\nApplication tagging\n\n\nYou can tag your application with the B4S SDK. You can set two values : The first parameter is the event descriptor and the second the userData asociated to the event. \n\n\nB4S.event(\nLaunch\n,\nNo Data\n);\n\n\n\n\nYou can even set your own data dictionary.\n\n\nHashtable tags = new Hashtable();\ntags.put(\nKey1\n,\nString1\n);\ntags.put(\nKey2\n,\nString2\n);\ntags.put(\nKey3\n,4);\nB4STag.event(\nTest\n, tags);\n\n\n\n\nCustom notifications\n\n\nIcons, icon background colour and vibration can be customised on notifications.\n\n\nB4SSettings.get().setNotificationBackgroundColor(0xff111111);\nB4SSettings.get().setCustomNotificationSmallIcon(R.drawable.ic_notifsmall);\nB4SSettings.get().setCustomNotificationLargeIcon(R.drawable.ic_notiflarge);\nB4SSettings.get().setShouldVibrateOnNotification(true);\n\n\n\n\nPush notifications\n\n\nTo use remote push notifications you must first follow the instructions of the \"Base integration\"\n\n\nTo use remote push messaging with the Neerby SDK, ensure that the \nplay-services-gcm\n library is properly specified in your \napp/build.gradle\n dependencies:\n\n\n{\n    compile 'com.google.android.gms:play-services-gcm:8.4.0'\n}\n\n\n\n\nDeep linking\n\n\nNotifications such as web links or simple messages are handled directly by the SDK. For deep linking (and deep linking only), there are three options:\n\n\n\n\nDeepLinkStyle.LaunchActivityClearTask\n - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)\n\n\nDeepLinkStyle.LaunchActivityDirect\n - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your \nonNewIntent\n lifecycle method\n\n\nDeepLinkStyle.BroadcastReceiver\n - Deep links are broadcasted with a \ncom.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK\n Intent action type\n\n\n\n\nThe strategy can be set by calling a static method, typically after you have initialized the SDK in your \nApplication\n class:\n\n\n   NotificationService.registerDeepLinkStyle(NotificationService.DeepLinkStyle deepLinkStyle);\n\n\n\n\nWhen you configure to use \nDeepLinkStyle.BroadcastReceiver\n deep links, the application can and must register a \nBroadcastReceiver\n that handles the deep links, such as opening a specific Activity or starting a Service. In your \nAndroidManifest.xml\n you declare:\n\n\n   \nreceiver android:name=\n.DeepLinkReceiver\n\n      \nintent-filter\n\n         \naction android:name=\ncom.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK\n /\n\n      \n/intent-filter\n\n   \n/receiver\n\n\n\n\n\nThe \nDeepLinkReceiver\n can, in its simplest form, simply relay the broadcasts to some other Activity:\n\n\n    public class DeepLinkReceiver extends BroadcastReceiver {\n       @Override\n       public void onReceive(Context context, Intent intent) {\n          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // Required as no Activity context is available\n          context.startActivity(intent);\n       }\n    }\n\n\n\n\nDeep link \nIntent\ns contain a bundle of extras to respond appropriately:\n\n\n\n\nNotificationService.INTENT_SHOW\n - (int) Hash code of the interaction that was matched\n\n\nNotificationService.INTENT_INTERACTION\n - (String) Name interaction that was matched\n\n\nNotificationService.INTENT_CAMPAIGNNAME\n - (String) Name of the campaign the matched interaction belongs to\n\n\nNotificationService.INTENT_INTERACTIONNAME\n - (String) Unique ID of the interaction that was matched\n\n\nNotificationService.INTENT_TITLE\n - (String) Message title, defaults to interaction name if no custom title was supplied\n\n\nNotificationService.INTENT_MESSAGE\n - (String) Message, in which customer name, beacon name, shop name, etc. were already substituted\n\n\nNotificationService.INTENT_SHOPNAME\n - (String) Name of the interaction's shop\n\n\nNotificationService.INTENT_SHOPCLIENTREF\n - (String) The free-form string set on the shop as client reference\n\n\nNotificationService.INTENT_GROUPNAME\n - (String) Name of the interaction's group\n\n\nNotificationService.INTENT_ACTIONID\n - (String) The free-form string with the campaign action id set as deep link reference\n\n\nNotificationService.INTENT_BEACONNAME\n - (String) Name of the matched beacon as configured in the SDK\n\n\nNotificationService.INTENT_BEACONID\n - (IBeaconID) Beacon identification, including technical name (B4S:XXXX:XXXX), UDID, major and minor\n\n\nNotificationService.INTENT_BEACONCLIENTREF\n - (String) The free-form string set on the beacon as client reference\n\n\nNotificationService.INTENT_DISTANCE\n - (double) Distance estimate in meters\n\n\nNotificationService.INTENT_SHOPLATITUDE\n - (double) Latitude of the shop associated to the notification\n\n\nNotificationService.INTENT_SHOPLONGITUDE\n - (double) Longitude of the shop associated to the notification\n\n\n\n\nDynamic notifications customisation\n\n\nYou have the possibility to let your code modify every notification before they are display to the use.\n\n\nIn order to achieve this, you had to :\n\n\n\n\nAdd the NotificationService.NotificationModifier interface to the class which will be responsible of the notifications customisation.\n\n\nRegister the previous class with \n\n\n\n\n    NotificationService.registerNotificationModifier(this);\n\n\n\n\n\n\nImplements the two methods :\n\n\n\n\npublic String modifyNotificationTitle(Bundle extras) {\n\n}\n\npublic String modifyNotificationMessage(Bundle extras) {\n\n}\n\n\n\n\nThe string returned by these methods will be respectively the modified title and message of the notification. You can even modify the notification properties of the notifications.\n\n\nAndroid 6\n\n\nWith Android 6.0 (API level 23) a new permission system was introduced by Google. On Android 6 devices, users can manually manage permissions on a per-application basis. If an app targets Android 6 (using targetSdkVersion 23 and compileSdkVersion 23), an app also needs to deal with runtime permissions. This means that permissions such as location access (which is now a so-called 'dangerous' permission) needs to be explicitly requested with a permission request pop-up. Until SDK version 1.4.2, the B4S SDK does not handle this automatically and therefor the integrator needs to \nhandle permission request dialogs manually\n.\n\n\nFrom version 1.5.0 onwards this will be handled for you by the SDK. A request to access the user location will automatically be shown when access was not yet granted. It is important to note that this affects any application when running on an Android 6 device, even those that still target API level 22 or lower.\n\n\nUsing a transient device UUID\n\n\nWarning\n: using this feature is \nnot\n recommended\n\n\nUpon the app installation, an anymous and persistent device UUID is used if the app is un-installed then re-installed. To make this ID transient add a \nby.neer.sdk.USE_TRANSIENT_DEVICEID\n key to your AndroidManifest.xml, with the value \ntrue\n in the application block.\n\n\nmeta-data android:name=\nby.neer.sdk.USE_TRANSIENT_DEVICEID\n android:value=\ntrue\n /\n\n\n\n\n\nGetting the user's worlplace and home coordinates\n\n\nThe SDK tries to determinate the user's home \n workplace coordinate. When accessing those, home and workplace coordinates should be null if the SDK still do not collect enough information to identify the customer home and workplace locations.\n\n\n\nLocation home = B4SSettings.get().userHomeCoordinates();\nif (home != null)\n{\n    // Use the coordinates\n}\nLocation work = B4SSettings.get().userWorkplaceCoordinates();\nif (work != null)\n{\n    // Use the coordinates\n}", 
            "title": "Using the SDK"
        }, 
        {
            "location": "/using_the_sdk/#base-integration", 
            "text": "Add the  Application ID  provided by Ezeeworld to the  Application  object in you  AndroidManifest.xml . Depending on your project configuration you might have to create this object  application\n   android:name= com.ezeeworld.b4s.android.sdk.sample.SampleApp \n   android:label= @string/app_name   \n   ...\n    meta-data android:name= by.neer.sdk.APP_ID  android:value= MY-APP-ID  / \n   ... /application   And replace  MY-APP-ID  with your unique application ID.  Import the SDK in your Application subclass:  import com.ezeeworld.b4s.android.sdk.B4SSettings;\nimport com.ezeeworld.b4s.android.sdk.monitor.MonitoringManager;  Start the SDK in the  onCreate  method:  B4SSettings settings = B4SSettings.init(this);\nMonitoringManager.ensureMonitoringService(this);", 
            "title": "Base integration"
        }, 
        {
            "location": "/using_the_sdk/#prevent-your-application-to-trigger-notifications-resulting-of-mock-locations", 
            "text": "On Android, some applications (like Lockito) can generate mock locations (typically for debuging purpose). By default, mock locations are authorised by the Neer.by SDK. You can disable them with the following code :  B4SSettings.get().setDiscardMockLocations(true);", 
            "title": "Prevent your application to trigger notifications resulting of mock locations"
        }, 
        {
            "location": "/using_the_sdk/#recording-user-data", 
            "text": "Neerby can relate events to individual customers. Supplying the customer details is typically done on startup and/or after a user signed in to his/her account. In these cases you can update te SDK with this customer data (which is persisted; no need to call this every time). The key should use reverse-dns-like notation to be used as a domain. For instance, the user hometown should use a \"user.hometown\" key. A few keys are provided (Firstname, lastname, gender...)  B4SUserProperty.get().store(B4SUserProperty.USER_FIRST_NAME,  Jean-Michel );\nB4SUserProperty.get().store(B4SUserProperty.USER_LAST_NAME,  B\u00e9catresse );\nB4SUserProperty.get().store(B4SUserProperty.USER_GENDER, B4SUserProperty.Gender.Male);\nB4SUserProperty.get().store( user.hometown ,  Tubbydome );", 
            "title": "Recording user data"
        }, 
        {
            "location": "/using_the_sdk/#application-tagging", 
            "text": "You can tag your application with the B4S SDK. You can set two values : The first parameter is the event descriptor and the second the userData asociated to the event.   B4S.event( Launch , No Data );  You can even set your own data dictionary.  Hashtable tags = new Hashtable();\ntags.put( Key1 , String1 );\ntags.put( Key2 , String2 );\ntags.put( Key3 ,4);\nB4STag.event( Test , tags);", 
            "title": "Application tagging"
        }, 
        {
            "location": "/using_the_sdk/#custom-notifications", 
            "text": "Icons, icon background colour and vibration can be customised on notifications.  B4SSettings.get().setNotificationBackgroundColor(0xff111111);\nB4SSettings.get().setCustomNotificationSmallIcon(R.drawable.ic_notifsmall);\nB4SSettings.get().setCustomNotificationLargeIcon(R.drawable.ic_notiflarge);\nB4SSettings.get().setShouldVibrateOnNotification(true);", 
            "title": "Custom notifications"
        }, 
        {
            "location": "/using_the_sdk/#push-notifications", 
            "text": "To use remote push notifications you must first follow the instructions of the \"Base integration\"  To use remote push messaging with the Neerby SDK, ensure that the  play-services-gcm  library is properly specified in your  app/build.gradle  dependencies:  {\n    compile 'com.google.android.gms:play-services-gcm:8.4.0'\n}", 
            "title": "Push notifications"
        }, 
        {
            "location": "/using_the_sdk/#deep-linking", 
            "text": "Notifications such as web links or simple messages are handled directly by the SDK. For deep linking (and deep linking only), there are three options:   DeepLinkStyle.LaunchActivityClearTask  - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)  DeepLinkStyle.LaunchActivityDirect  - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your  onNewIntent  lifecycle method  DeepLinkStyle.BroadcastReceiver  - Deep links are broadcasted with a  com.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK  Intent action type   The strategy can be set by calling a static method, typically after you have initialized the SDK in your  Application  class:     NotificationService.registerDeepLinkStyle(NotificationService.DeepLinkStyle deepLinkStyle);  When you configure to use  DeepLinkStyle.BroadcastReceiver  deep links, the application can and must register a  BroadcastReceiver  that handles the deep links, such as opening a specific Activity or starting a Service. In your  AndroidManifest.xml  you declare:      receiver android:name= .DeepLinkReceiver \n       intent-filter \n          action android:name= com.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK  / \n       /intent-filter \n    /receiver   The  DeepLinkReceiver  can, in its simplest form, simply relay the broadcasts to some other Activity:      public class DeepLinkReceiver extends BroadcastReceiver {\n       @Override\n       public void onReceive(Context context, Intent intent) {\n          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // Required as no Activity context is available\n          context.startActivity(intent);\n       }\n    }  Deep link  Intent s contain a bundle of extras to respond appropriately:   NotificationService.INTENT_SHOW  - (int) Hash code of the interaction that was matched  NotificationService.INTENT_INTERACTION  - (String) Name interaction that was matched  NotificationService.INTENT_CAMPAIGNNAME  - (String) Name of the campaign the matched interaction belongs to  NotificationService.INTENT_INTERACTIONNAME  - (String) Unique ID of the interaction that was matched  NotificationService.INTENT_TITLE  - (String) Message title, defaults to interaction name if no custom title was supplied  NotificationService.INTENT_MESSAGE  - (String) Message, in which customer name, beacon name, shop name, etc. were already substituted  NotificationService.INTENT_SHOPNAME  - (String) Name of the interaction's shop  NotificationService.INTENT_SHOPCLIENTREF  - (String) The free-form string set on the shop as client reference  NotificationService.INTENT_GROUPNAME  - (String) Name of the interaction's group  NotificationService.INTENT_ACTIONID  - (String) The free-form string with the campaign action id set as deep link reference  NotificationService.INTENT_BEACONNAME  - (String) Name of the matched beacon as configured in the SDK  NotificationService.INTENT_BEACONID  - (IBeaconID) Beacon identification, including technical name (B4S:XXXX:XXXX), UDID, major and minor  NotificationService.INTENT_BEACONCLIENTREF  - (String) The free-form string set on the beacon as client reference  NotificationService.INTENT_DISTANCE  - (double) Distance estimate in meters  NotificationService.INTENT_SHOPLATITUDE  - (double) Latitude of the shop associated to the notification  NotificationService.INTENT_SHOPLONGITUDE  - (double) Longitude of the shop associated to the notification", 
            "title": "Deep linking"
        }, 
        {
            "location": "/using_the_sdk/#dynamic-notifications-customisation", 
            "text": "You have the possibility to let your code modify every notification before they are display to the use.  In order to achieve this, you had to :   Add the NotificationService.NotificationModifier interface to the class which will be responsible of the notifications customisation.  Register the previous class with        NotificationService.registerNotificationModifier(this);   Implements the two methods :   public String modifyNotificationTitle(Bundle extras) {\n\n}\n\npublic String modifyNotificationMessage(Bundle extras) {\n\n}  The string returned by these methods will be respectively the modified title and message of the notification. You can even modify the notification properties of the notifications.", 
            "title": "Dynamic notifications customisation"
        }, 
        {
            "location": "/using_the_sdk/#android-6", 
            "text": "With Android 6.0 (API level 23) a new permission system was introduced by Google. On Android 6 devices, users can manually manage permissions on a per-application basis. If an app targets Android 6 (using targetSdkVersion 23 and compileSdkVersion 23), an app also needs to deal with runtime permissions. This means that permissions such as location access (which is now a so-called 'dangerous' permission) needs to be explicitly requested with a permission request pop-up. Until SDK version 1.4.2, the B4S SDK does not handle this automatically and therefor the integrator needs to  handle permission request dialogs manually .  From version 1.5.0 onwards this will be handled for you by the SDK. A request to access the user location will automatically be shown when access was not yet granted. It is important to note that this affects any application when running on an Android 6 device, even those that still target API level 22 or lower.", 
            "title": "Android 6"
        }, 
        {
            "location": "/using_the_sdk/#using-a-transient-device-uuid", 
            "text": "Warning : using this feature is  not  recommended  Upon the app installation, an anymous and persistent device UUID is used if the app is un-installed then re-installed. To make this ID transient add a  by.neer.sdk.USE_TRANSIENT_DEVICEID  key to your AndroidManifest.xml, with the value  true  in the application block.  meta-data android:name= by.neer.sdk.USE_TRANSIENT_DEVICEID  android:value= true  /", 
            "title": "Using a transient device UUID"
        }, 
        {
            "location": "/using_the_sdk/#getting-the-users-worlplace-and-home-coordinates", 
            "text": "The SDK tries to determinate the user's home   workplace coordinate. When accessing those, home and workplace coordinates should be null if the SDK still do not collect enough information to identify the customer home and workplace locations.  \nLocation home = B4SSettings.get().userHomeCoordinates();\nif (home != null)\n{\n    // Use the coordinates\n}\nLocation work = B4SSettings.get().userWorkplaceCoordinates();\nif (work != null)\n{\n    // Use the coordinates\n}", 
            "title": "Getting the user's worlplace and home coordinates"
        }, 
        {
            "location": "/migration_guide/", 
            "text": "Migration guide\n\n\nPlease refer to each individual version step when migrating to a newer SDK. The SDK uses \nSemantic Versioning\n\n\nThe \nIntegration Guide\n always describes the most up-to-date integration requirements.\n\n\nUpgrade to 2.2.0\n\n\nThe APP-ID should now be set in your application Manifest. The previous installation method is now deprecated. This process is detailed in the installation documentation.\nWe are now using the version 2.2.0 of retrofit.\n\n\nUpgrade to 1.8.4\n\n\nNo changes required.\n\n\nUpgrade to 1.8.3\n\n\nNo code changes required. The minimum SDK level is now set to 10, so applications targeting Android 2.3 can include the library without the need to an \noverrideLibrary\n attribute in their \nuses-sdk /\n manifest declaration.\n\n\nUpgrade to 1.8.2\n\n\nNo changes required.\n\n\nUpgrade to 1.8.1\n\n\nThe deep linking strategy can now optionally be changed. While the default delivery to the launcher Activity in a new task remains unchanged, three strategies are now available:\n\n\n\n\nLaunchActivityClearTask\n - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)\n\n\nLaunchActivityDirect\n - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your \nonNewIntent\n lifecycle method\n\n\nBroadcastReceiver\n - Deep links are broadcasted with a \ncom.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK\n Intent action type\n\n\n\n\nPlease refer to the [[deep linking section|Integration-guide#deep-linking]] in the main integration document for implementation details.\n\n\nUpgrade to 1.8.0\n\n\nA Play Services support library was added in case you want to upgrade to the Play Services 8.4. Just use the \nb4s-android-sdk-playservices840.aar\n  file instead of the existing \nplayservicesXXX\n variant.\n\n\nThe Retrofit dependency was updated to incorporate stability changes and be compatible with apps that still use Retrofit 1.X. Make sure your dependency looks like:\n\n\ndependencies {\n    compile 'com.squareup.retrofit2:retrofit:2.0.0-beta3'\n    compile 'com.squareup.retrofit2:converter-jackson:2.0.0-beta3'\n    ...\n}\n\n\n\n\nLocal logging was changed from a level-based to a feature-based distinction. To enable logging, now use the \nB4SSetting.setShouldLogScan(boolean)\n and \nB4SSetting.setShouldLogMatching(boolean)\n methods instead of \nsetShouldLogDebug\n and \nsetShouldLogVerbose\n. Scanning-related logs are reported using the \nB4SSCN\n tag, which campaign matching logs are still using the \nB4S\n tag. For example, to get all logs, use \nadb logcat -s B4SSCN:* B4S:*\n or to only get info and higher priority logs about campaign matching you can use \nadb logcat -s B4S:I\n.\n\n\nUpgrade to 1.7.0\n\n\nThe dependencies were updated for stability and additional functionality. Note that there is now an additional \ncupboard\n dependency. For Eclipse builds, the required jar files can be found in the \n/sample-eclipse/libs\n folder. For Gradle builds, ensure you refer to the correct versions:\n\n\ndependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'\n    compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'\n    ...\n}\n\n\n\n\nUpgrade to 1.6.1\n\n\nWhen using the .JAR release with manual declarations in your \nAndroidManifest.xml\n, ensure that the GCM \npermission\n and \nuses-permission\n include your unique package name (instead of the placeholder \nYOUR-PACKAGE-NAME\n):\n\n\n   \npermission\n      android:name=\nYOUR-PACKAGE-NAME\n.permission.C2D_MESSAGE\n\n      android:protectionLevel=\nsignature\n /\n\n   \nuses-permission android:name=\nYOUR-PACKAGE-NAME\n.permission.C2D_MESSAGE\n /\n\n\n\n\n\nThe .AAR version (with Gradle) automatically injects the proper application id in the permission name, starting with this release.\n\n\nUpgrade to 1.6.0\n\n\nThe SDK was split into a core part and a connection part specific to the Play Services library that the application wants to use. This allows, for example, to stay at Play Services 6.5 while still upgrading to the latest B4S version.\n\n\nSecondly, the SDK is now also released in .AAR format, next to the existing .JAR format. When Gradle is used as build system, it is strongly recommended to use the .AAR format as it no longer requires manually declaring B4S services in the Android Manifest.\n\n\nTo upgrade start by removing the B4S services (and activities and broadcast receivers) from your \nAndroidManifest.xml\n. Next, remove the \nb4s-android-sdk.jar\n from your \n/libs\n folder and replace it with the \nb4s-android-sdk.aar\n and  \nb4s-android-sdk-playservicesXXX.aar\n .AAR files from the \n/sdk/aar\n release folder\n. The version of the \n-playservices\n .JAR file should correspond to your Play Services version. For example, use \nb4s-android-sdk-playservices830.jar\n if you are at Play Services 8.3 (v28). Finally, in your root \n/build.gradle\n file, ensure that the libs directory is added to the \nrepositories\n list. This part now looks something like:\n\n\nallprojects {\n    repositories {\n        jcenter()\n        flatDir{\n            dirs 'libs'\n        }\n    }\n}\n\n\n\n\nFinally, in you applciations' \napp/build.gradle\n file, add the .AAR file dependencies, For example:\n\n\n    compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices830', ext:'aar')\n\n\n\n\nSee the \nsample-gradle\n sample project\n for an up-to-date configuration which uses Play Services 8.3.\n\n\nUpgrade to 1.5.5\n\n\nThe Google Cloud Messaging (play-services-gcm) dependency is no longer a requirement if (and only if) push messaging is not used.\n\n\nUpgrade to 1.5.4\n\n\nNo changes required.\n\n\nUpgrade to 1.5.2\n\n\nIf multiple B4S apps are installed, the SDK will now automatically choose the most recent SDK version to scan for beacons. This requires additional intent filter definitions for the \nMonitoringManager\n service. Please ensure that it is defined as:\n\n\nservice\nandroid:name=\ncom.ezeeworld.b4s.android.sdk.monitor.MonitoringManager\n\nandroid:exported=\ntrue\n\ntools:ignore=\nExportedService\n\n    \nintent-filter\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_ENSURE_SCANNING\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_SCHEDULE\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_SCHEDULE_RESULT\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_VERSION\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_REPORT_VERSION\n /\n\n    \n/intent-filter\n\n\n/service\n\n\n\n\n\nUpgrade to 1.5.0\n\n\nThe dependencies were updated for better compatibility with recent Play Services and stability. For Eclipse builds, the required jar files can be found in the /sdk/libs folder. For Gradle builds, ensure you refer to the correct versions:\n\n\n   dependencies {\n      compile 'de.greenrobot:eventbus:2.3.0'\n      compile 'com.squareup.retrofit:retrofit:2.0.0-beta1'\n      compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta1'\n      compile 'com.google.android.gms:play-services-location:8.1.0'\n      compile 'com.google.android.gms:play-services-ads:8.1.0'\n      compile \ncom.google.android.gms:play-services-gcm:8.1.0\n\n      compile fileTree(dir: 'libs', include: ['*.jar'])\n   }\n\n\n\n\nIt is no longer necessary (nor should you) to extend from the \nB4SNotificationActivity\n or manage a \nB4SNotificationPopup\n manually. Please remove manual references to these class from your code. Not that, as part of this change, you DO have to supply your \nApplication\n object to the \nB4SSettings.init(Application, String)\n method.\n\n\nThe deep linking intent extra field constants, such as \nINTENT_TITLE\n and \nINTENT_ACTIONID\n, were moved from the \nMonitoringManager\n to the \nNotificationService\n class.\n\n\nThe scanning service was updated for greater speed and reliability, especially on devices with poor Bluetooth hardware. The demo mode (which was exclusively used for testing) is deprecated so the \nB4SSettings.setDemoMode(boolean)\n was removed.\n\n\nOn Android 6.0 a new runtime permission system was introduced, and this is now natively supported. When the user has not (yet) given permissions for the \nandroid.permission-group.LOCATION\n group, the SDK will show a request pop-up. Note that no alerts (pop-ups) will be shown if location services or bluetooth are disabled, although this \nmay now be configured\n.\n\n\nThe \nB4SSettings.storeCustomerFields()\n method was slightly changed, as it is no longer needed to supply a location while a \nuserId\n parameter was added.\n\n\nUpgrade to 1.4.5\n\n\nPush messaging support\n was added, for which a new \nB4SSettings.setPushMessagingSenderId(String)\n method was introduced. As part of the feature, the notification generation was moved and a new service declaration is required:\n\n\n      \nservice\n         android:name=\ncom.ezeeworld.b4s.android.sdk.notifications.NotificationService\n\n         android:exported=\nfalse\n /\n\n\n\n\n\nFor push messaging integration itself, please refer to the \nfull integration document\n.", 
            "title": "Migration guide"
        }, 
        {
            "location": "/migration_guide/#migration-guide", 
            "text": "Please refer to each individual version step when migrating to a newer SDK. The SDK uses  Semantic Versioning  The  Integration Guide  always describes the most up-to-date integration requirements.", 
            "title": "Migration guide"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-220", 
            "text": "The APP-ID should now be set in your application Manifest. The previous installation method is now deprecated. This process is detailed in the installation documentation.\nWe are now using the version 2.2.0 of retrofit.", 
            "title": "Upgrade to 2.2.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-184", 
            "text": "No changes required.", 
            "title": "Upgrade to 1.8.4"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-183", 
            "text": "No code changes required. The minimum SDK level is now set to 10, so applications targeting Android 2.3 can include the library without the need to an  overrideLibrary  attribute in their  uses-sdk /  manifest declaration.", 
            "title": "Upgrade to 1.8.3"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-182", 
            "text": "No changes required.", 
            "title": "Upgrade to 1.8.2"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-181", 
            "text": "The deep linking strategy can now optionally be changed. While the default delivery to the launcher Activity in a new task remains unchanged, three strategies are now available:   LaunchActivityClearTask  - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)  LaunchActivityDirect  - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your  onNewIntent  lifecycle method  BroadcastReceiver  - Deep links are broadcasted with a  com.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK  Intent action type   Please refer to the [[deep linking section|Integration-guide#deep-linking]] in the main integration document for implementation details.", 
            "title": "Upgrade to 1.8.1"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-180", 
            "text": "A Play Services support library was added in case you want to upgrade to the Play Services 8.4. Just use the  b4s-android-sdk-playservices840.aar   file instead of the existing  playservicesXXX  variant.  The Retrofit dependency was updated to incorporate stability changes and be compatible with apps that still use Retrofit 1.X. Make sure your dependency looks like:  dependencies {\n    compile 'com.squareup.retrofit2:retrofit:2.0.0-beta3'\n    compile 'com.squareup.retrofit2:converter-jackson:2.0.0-beta3'\n    ...\n}  Local logging was changed from a level-based to a feature-based distinction. To enable logging, now use the  B4SSetting.setShouldLogScan(boolean)  and  B4SSetting.setShouldLogMatching(boolean)  methods instead of  setShouldLogDebug  and  setShouldLogVerbose . Scanning-related logs are reported using the  B4SSCN  tag, which campaign matching logs are still using the  B4S  tag. For example, to get all logs, use  adb logcat -s B4SSCN:* B4S:*  or to only get info and higher priority logs about campaign matching you can use  adb logcat -s B4S:I .", 
            "title": "Upgrade to 1.8.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-170", 
            "text": "The dependencies were updated for stability and additional functionality. Note that there is now an additional  cupboard  dependency. For Eclipse builds, the required jar files can be found in the  /sample-eclipse/libs  folder. For Gradle builds, ensure you refer to the correct versions:  dependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'\n    compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'\n    ...\n}", 
            "title": "Upgrade to 1.7.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-161", 
            "text": "When using the .JAR release with manual declarations in your  AndroidManifest.xml , ensure that the GCM  permission  and  uses-permission  include your unique package name (instead of the placeholder  YOUR-PACKAGE-NAME ):      permission\n      android:name= YOUR-PACKAGE-NAME .permission.C2D_MESSAGE \n      android:protectionLevel= signature  / \n    uses-permission android:name= YOUR-PACKAGE-NAME .permission.C2D_MESSAGE  /   The .AAR version (with Gradle) automatically injects the proper application id in the permission name, starting with this release.", 
            "title": "Upgrade to 1.6.1"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-160", 
            "text": "The SDK was split into a core part and a connection part specific to the Play Services library that the application wants to use. This allows, for example, to stay at Play Services 6.5 while still upgrading to the latest B4S version.  Secondly, the SDK is now also released in .AAR format, next to the existing .JAR format. When Gradle is used as build system, it is strongly recommended to use the .AAR format as it no longer requires manually declaring B4S services in the Android Manifest.  To upgrade start by removing the B4S services (and activities and broadcast receivers) from your  AndroidManifest.xml . Next, remove the  b4s-android-sdk.jar  from your  /libs  folder and replace it with the  b4s-android-sdk.aar  and   b4s-android-sdk-playservicesXXX.aar  .AAR files from the  /sdk/aar  release folder . The version of the  -playservices  .JAR file should correspond to your Play Services version. For example, use  b4s-android-sdk-playservices830.jar  if you are at Play Services 8.3 (v28). Finally, in your root  /build.gradle  file, ensure that the libs directory is added to the  repositories  list. This part now looks something like:  allprojects {\n    repositories {\n        jcenter()\n        flatDir{\n            dirs 'libs'\n        }\n    }\n}  Finally, in you applciations'  app/build.gradle  file, add the .AAR file dependencies, For example:      compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices830', ext:'aar')  See the  sample-gradle  sample project  for an up-to-date configuration which uses Play Services 8.3.", 
            "title": "Upgrade to 1.6.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-155", 
            "text": "The Google Cloud Messaging (play-services-gcm) dependency is no longer a requirement if (and only if) push messaging is not used.", 
            "title": "Upgrade to 1.5.5"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-154", 
            "text": "No changes required.", 
            "title": "Upgrade to 1.5.4"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-152", 
            "text": "If multiple B4S apps are installed, the SDK will now automatically choose the most recent SDK version to scan for beacons. This requires additional intent filter definitions for the  MonitoringManager  service. Please ensure that it is defined as:  service\nandroid:name= com.ezeeworld.b4s.android.sdk.monitor.MonitoringManager \nandroid:exported= true \ntools:ignore= ExportedService \n     intent-filter \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_ENSURE_SCANNING  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_SCHEDULE  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_SCHEDULE_RESULT  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_VERSION  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_REPORT_VERSION  / \n     /intent-filter  /service", 
            "title": "Upgrade to 1.5.2"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-150", 
            "text": "The dependencies were updated for better compatibility with recent Play Services and stability. For Eclipse builds, the required jar files can be found in the /sdk/libs folder. For Gradle builds, ensure you refer to the correct versions:     dependencies {\n      compile 'de.greenrobot:eventbus:2.3.0'\n      compile 'com.squareup.retrofit:retrofit:2.0.0-beta1'\n      compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta1'\n      compile 'com.google.android.gms:play-services-location:8.1.0'\n      compile 'com.google.android.gms:play-services-ads:8.1.0'\n      compile  com.google.android.gms:play-services-gcm:8.1.0 \n      compile fileTree(dir: 'libs', include: ['*.jar'])\n   }  It is no longer necessary (nor should you) to extend from the  B4SNotificationActivity  or manage a  B4SNotificationPopup  manually. Please remove manual references to these class from your code. Not that, as part of this change, you DO have to supply your  Application  object to the  B4SSettings.init(Application, String)  method.  The deep linking intent extra field constants, such as  INTENT_TITLE  and  INTENT_ACTIONID , were moved from the  MonitoringManager  to the  NotificationService  class.  The scanning service was updated for greater speed and reliability, especially on devices with poor Bluetooth hardware. The demo mode (which was exclusively used for testing) is deprecated so the  B4SSettings.setDemoMode(boolean)  was removed.  On Android 6.0 a new runtime permission system was introduced, and this is now natively supported. When the user has not (yet) given permissions for the  android.permission-group.LOCATION  group, the SDK will show a request pop-up. Note that no alerts (pop-ups) will be shown if location services or bluetooth are disabled, although this  may now be configured .  The  B4SSettings.storeCustomerFields()  method was slightly changed, as it is no longer needed to supply a location while a  userId  parameter was added.", 
            "title": "Upgrade to 1.5.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-145", 
            "text": "Push messaging support  was added, for which a new  B4SSettings.setPushMessagingSenderId(String)  method was introduced. As part of the feature, the notification generation was moved and a new service declaration is required:         service\n         android:name= com.ezeeworld.b4s.android.sdk.notifications.NotificationService \n         android:exported= false  /   For push messaging integration itself, please refer to the  full integration document .", 
            "title": "Upgrade to 1.4.5"
        }
    ]
}