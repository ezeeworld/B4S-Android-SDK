{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome Neerby SDK Android\n\n\nFor more details about the project visit \nNeer.by", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-neerby-sdk-android", 
            "text": "For more details about the project visit  Neer.by", 
            "title": "Welcome Neerby SDK Android"
        }, 
        {
            "location": "/include_in_project/", 
            "text": "Hardware \n software requirements\n\n\nThe Neerby SDK uses Bluetooth 4.0 BLE (Bluetooth Low Energy) and thus is only available on the devices running  \nAndroid 4.3\n, API level 18. \n\n\nAs Android 4.3 introduced support for Bluetooth LE, API level 18 is the minimum API level requirement for the SDK to work with beacons. However, it is safe to include the library in an application that support older Android versions. Since SDK 1.8.3 the minimum target is API level 10. If you need an even lower SDK, you can simply have Gradle ignore the B4S minimum SDK level by adding to your \nAndroidManifest.xml\n:\n\n\n  \nuses-sdk tools:overrideLibrary=\ncom.ezeeworld.b4s.android.sdk, com.ezeeworld.b4s.android.sdk.playservices\n /\n\n\n\n\n\nInstallation\n\n\nYou must perform the following tasks to integrate the Neerby SDK with your application:\n\n\n\n\nGet your application ID\n\n\nImport required librairies manually or using \nMaven\n\n\nAdapt your \n.gradle\n files\n\n\nCode-level integration\n\n\n\n\nGet your application ID\n\n\nIn order to use the SDK you must know the application ID that is tied to your Neerby account. \n\n\n\n\nGo to \nNeerby Web Manager\n\n\nLog-in with your Neerby account\n\n\nGo to the \"Applications\" section\n\n\nSelect your application ID\n\n\n\n\nManual installation\n\n\nThe SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root \nbuild.gradle\n file you should have a \nrepositories\n element, to which the plain libraries directory should be added, typically called \nlibs\n:\n\n\nallprojects {\n    repositories {\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}\n\n\n\n\nSee \nthe \nsample-gradle\n root project's \nbuild.gradle\n file\n for an example of this repository declaration.\n\n\nNext, add all the B4S dependencies and reference its .AAR files in the main application's \napp/build.gradle\n file:\n\n\ndependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:11.6.2'\n    compile 'com.google.android.gms:play-services-ads:11.6.2'\n    compile 'com.google.android.gms:play-services-gcm:11.6.2'\n    compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices1162', ext:'aar')\n}\n\n\n\n\nImportant\n: This example relies on the Play Services version 11.6.2, but the SDK is compatible with versions of the Play Services starting with 10.2.6. Previous PlayServices versions are no more supported since they may cause crashes on Android 8.x. Simply refer to the desired \nplay-services-xxx\n libraries as usual and select the corresponding \nb4s-android-sdk-playservicesXXX.aar\n file. For example, if the Play Services 11.0 (v2) should be used instead:\n\n\n    ...\n    compile 'com.google.android.gms:play-services-location:11.0.2'\n    compile 'com.google.android.gms:play-services-ads:11.0.2'\n    ...\n    compile (name:'b4s-android-sdk-playservices1102', ext:'aar')\n\n\n\n\nThe Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the \nbuildTypes\n part of your Gradle file a \npackagingOptions\n element to include the license files:\n\n\n    buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }\n\n\n\n\nSee \nthe \nsample-gradle\n app module's \napp/build.gradle\n file\n for an example, including all the dependencies.\n\n\nFinally, copy the \nb4s-android-sdk.aar\n and the \nb4s-android-sdk-playservicesXXX.aar\n version of your choice from the \n/sdk/aar\n release directory\n to your \napp/libs\n directory.\n\n\nInstallation using Maven\n\n\nTo simplify your integration you can use \nMaven\n\n\nThe SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root \nbuild.gradle\n file you should have a \nrepositories\n element, to which our Maven repository should be added:the plain libraries directory should be added:\n\n\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \nhttp://maven.ezeeworld.com:8081/artifactory/libs-release-local\n }\n    }\n}\n\n\n\n\nNext, add all the B4S dependencies and reference its .AAR files in the main application's \napp/build.gradle\n file:\n\n\ndependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:11.0.2'\n    compile 'com.google.android.gms:play-services-ads:11.0.2'\n    compile 'com.google.android.gms:play-services-gcm:11.0.2'\n    compile 'by.neer.sdk:nby-playservices-support1102:2.3.9@aar'\n    compile 'by.neer.sdk:nby-sdk:2.3.9@aar'\n}\n\n\n\n\nThe Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the \nbuildTypes\n part of your Gradle file a \npackagingOptions\n element to include the license files:\n\n\n    buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }", 
            "title": "Include the SDK in your project"
        }, 
        {
            "location": "/include_in_project/#hardware-software-requirements", 
            "text": "The Neerby SDK uses Bluetooth 4.0 BLE (Bluetooth Low Energy) and thus is only available on the devices running   Android 4.3 , API level 18.   As Android 4.3 introduced support for Bluetooth LE, API level 18 is the minimum API level requirement for the SDK to work with beacons. However, it is safe to include the library in an application that support older Android versions. Since SDK 1.8.3 the minimum target is API level 10. If you need an even lower SDK, you can simply have Gradle ignore the B4S minimum SDK level by adding to your  AndroidManifest.xml :     uses-sdk tools:overrideLibrary= com.ezeeworld.b4s.android.sdk, com.ezeeworld.b4s.android.sdk.playservices  /", 
            "title": "Hardware &amp; software requirements"
        }, 
        {
            "location": "/include_in_project/#installation", 
            "text": "You must perform the following tasks to integrate the Neerby SDK with your application:   Get your application ID  Import required librairies manually or using  Maven  Adapt your  .gradle  files  Code-level integration", 
            "title": "Installation"
        }, 
        {
            "location": "/include_in_project/#get-your-application-id", 
            "text": "In order to use the SDK you must know the application ID that is tied to your Neerby account.    Go to  Neerby Web Manager  Log-in with your Neerby account  Go to the \"Applications\" section  Select your application ID", 
            "title": "Get your application ID"
        }, 
        {
            "location": "/include_in_project/#manual-installation", 
            "text": "The SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root  build.gradle  file you should have a  repositories  element, to which the plain libraries directory should be added, typically called  libs :  allprojects {\n    repositories {\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}  See  the  sample-gradle  root project's  build.gradle  file  for an example of this repository declaration.  Next, add all the B4S dependencies and reference its .AAR files in the main application's  app/build.gradle  file:  dependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:11.6.2'\n    compile 'com.google.android.gms:play-services-ads:11.6.2'\n    compile 'com.google.android.gms:play-services-gcm:11.6.2'\n    compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices1162', ext:'aar')\n}  Important : This example relies on the Play Services version 11.6.2, but the SDK is compatible with versions of the Play Services starting with 10.2.6. Previous PlayServices versions are no more supported since they may cause crashes on Android 8.x. Simply refer to the desired  play-services-xxx  libraries as usual and select the corresponding  b4s-android-sdk-playservicesXXX.aar  file. For example, if the Play Services 11.0 (v2) should be used instead:      ...\n    compile 'com.google.android.gms:play-services-location:11.0.2'\n    compile 'com.google.android.gms:play-services-ads:11.0.2'\n    ...\n    compile (name:'b4s-android-sdk-playservices1102', ext:'aar')  The Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the  buildTypes  part of your Gradle file a  packagingOptions  element to include the license files:      buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }  See  the  sample-gradle  app module's  app/build.gradle  file  for an example, including all the dependencies.  Finally, copy the  b4s-android-sdk.aar  and the  b4s-android-sdk-playservicesXXX.aar  version of your choice from the  /sdk/aar  release directory  to your  app/libs  directory.", 
            "title": "Manual installation"
        }, 
        {
            "location": "/include_in_project/#installation-using-maven", 
            "text": "To simplify your integration you can use  Maven  The SDK is distributed in .AAR format, which includes metadata such as definitions for its services. To add .AAR files to your application, first ensure that the build scripts can find them. In your root  build.gradle  file you should have a  repositories  element, to which our Maven repository should be added:the plain libraries directory should be added:  allprojects {\n    repositories {\n        jcenter()\n        maven { url  http://maven.ezeeworld.com:8081/artifactory/libs-release-local  }\n    }\n}  Next, add all the B4S dependencies and reference its .AAR files in the main application's  app/build.gradle  file:  dependencies {\n    compile 'nl.qbusict:cupboard:2.1.4'\n    compile 'de.greenrobot:eventbus:2.4.0'\n    compile 'com.squareup.retrofit2:converter-jackson:2.2.0'\n    compile 'com.google.android.gms:play-services-location:11.0.2'\n    compile 'com.google.android.gms:play-services-ads:11.0.2'\n    compile 'com.google.android.gms:play-services-gcm:11.0.2'\n    compile 'by.neer.sdk:nby-playservices-support1102:2.3.9@aar'\n    compile 'by.neer.sdk:nby-sdk:2.3.9@aar'\n}  The Jackson libraries dependencies ships with duplicate license files, which can be ignore by adding to the  buildTypes  part of your Gradle file a  packagingOptions  element to include the license files:      buildTypes {\n        ...\n        packagingOptions {\n            exclude 'META-INF/ASL2.0'\n            exclude 'META-INF/LICENSE'\n            exclude 'META-INF/NOTICE'\n        }\n    }", 
            "title": "Installation using Maven"
        }, 
        {
            "location": "/using_the_sdk/", 
            "text": "Depending on how you use the Neerby SDK, some steps are mandatory, some are optional.\n\n\n\n\nBase integration for counting visits\n\n\nRecording user data\n\n\nBeacon-based notifications\n\n\nApplication tagging\n\n\nPush notifications\n\n\n\n\nBase integration\n\n\n\n\nAdd the \nApplication ID\n provided by Ezeeworld to the \nApplication\n object in you \nAndroidManifest.xml\n. Depending on your project configuration you might have to create this object\n\n\n\n\napplication\n   android:name=\ncom.ezeeworld.b4s.android.sdk.sample.SampleApp\n\n   android:label=\n@string/app_name\n \n\n   ...\n   \nmeta-data android:name=\nby.neer.sdk.APP_ID\n android:value=\nMY-APP-ID\n /\n\n   \nmeta-data android:name=\nby.neer.sdk.AUTOSTART\n android:value=\ntrue\n /\n\n   \nmeta-data android:name=\nby.neer.sdk.DISABLE_AUTOMATIC_INIT\n android:value=\nfalse\n /\n\n   ...\n\n/application\n\n\n\n\n\nAnd replace \nMY-APP-ID\n with your unique application ID.\n\n\nWarning\n: if these keys are present with a valid application identifier, the SDK will init automatically upon app launch. It will register the device with the Neer.by server (but won't search for beacons, or display notifications, or send geolocalized information to our server). If you want to fully control when the device will be registered to our back-end, set \nby.neer.sdk.AUTOSTART\n and \nby.neer.sdk.DISABLE_AUTOMATIC_INIT\n keys to your Manifest, with respectively \nfalse\n and \ntrue\n value.\n\n\nxml\n \nmeta-data android:name=\"by.neer.sdk.AUTOSTART\" android:value=\"false\" /\n\n \nmeta-data android:name=\"by.neer.sdk.DISABLE_AUTOMATIC_INIT\" android:value=\"true\" /\n\n\n\n\nImport the SDK in your Application subclass:\n\n\n\n\nimport com.ezeeworld.b4s.android.sdk.B4SSettings;\n\n\n\n\n\n\nStart the SDK in the \nonCreate\n method:\n\n\n\n\nB4SSettings settings = B4SSettings.init(this);\nsettings.go();\n\n\n\n\n\n\nFinally startup the new geolocation tracking module :\n\n\n\n\npublic static LocationAwareThread lat = null;\n\nlat = LocationAwareThread.get();\nif (lat == null) {\n    lat = new LocationAwareThread(getApplicationContext());\n}\n\n\n\n\nWarning\n: Geolocation is required by the SDK. So you have to request \nandroid.Manifest.permission.ACCESS_FINE_LOCATION\n permission before calling B4SSettings.get().go()\n\n\n\n\nOn demand SDK activation\n\n\n\n\nThere is several way to condition SDK activation :\n\n\n1) Test location permission to prevent activation before permission are set.\n\n\nint res = PackageManager.PERMISSION_GRANTED;\nif (Build.VERSION.SDK_INT \n= Build.VERSION_CODES.M) {\n  res = getApplicationContext().checkSelfPermission(android.Manifest.permission.ACCESS_FINE_LOCATION);\n}\nLog.d(\nB4S\n, \nHabitsApplication init res=\n+res);\nif (res == PackageManager.PERMISSION_GRANTED) {\n  // Init SDK here\n}\n\n\n\n\n2) Test SharedPreferences value to locally enable SDK :\n\n\nboolean activateSdk = sharedPreferences.getBoolean(SDK_ACTIVATION, true);\nif (activateSdk) {\n  // Init SDK here\n}\n\n\n\n\nPrevent your application to trigger notifications resulting of mock locations\n\n\nOn Android, some applications (like Lockito) can generate mock locations (typically for debuging purpose). By default, mock locations are authorised by the Neer.by SDK. You can disable them with the following code :\n\n\nB4SSettings.get().setDiscardMockLocations(true);\n\n\n\n\nRecording user data\n\n\nNeerby can relate events to individual customers. Supplying the customer details is typically done on startup and/or after a user signed in to his/her account. In these cases you can update te SDK with this customer data (which is persisted; no need to call this every time). The key should use reverse-dns-like notation to be used as a domain. For instance, the user hometown should use a \"user.hometown\" key. A few keys are provided (Firstname, lastname, gender...)\n\n\nWhen the last parameter is set to false, the key/value is uploaded to our server. Uploaded key/values can be used to target users on interactions.\n\n\nB4SUserProperty.get().store(B4SUserProperty.USER_FIRST_NAME, \nJean-Michel\n, false);\nB4SUserProperty.get().store(B4SUserProperty.USER_LAST_NAME, \nB\u00e9catresse\n, false);\nB4SUserProperty.get().store(B4SUserProperty.USER_GENDER, B4SUserProperty.Gender.Male, true);\nB4SUserProperty.get().store(\nuser.hometown\n, \nTubbydome\n, true);\n\n\n\n\nApplication tagging\n\n\nYou can tag your application with the B4S SDK. You have to specify 2 informations :\n\u2022 A tag type\n\u2022 A data dictionnary with the datas associated to your tag.\n\n\nHashMap\nString, Object\n hmap = new HashMap();\nhmap.put(\nKey1\n, \nString1\n);\nhmap.put(\nKey2\n, 123);\nNeerbyTag.newEvent(getApplicationContext(), \nUserNavigation\n, hmap, true);\n\n\n\n\nCustom notifications\n\n\nIcons, icon background colour and vibration can be customised on notifications.\n\n\nB4SSettings.get().setNotificationBackgroundColor(0xff111111);\nB4SSettings.get().setCustomNotificationSmallIcon(R.drawable.ic_notifsmall);\nB4SSettings.get().setCustomNotificationLargeIcon(R.drawable.ic_notiflarge);\nB4SSettings.get().setShouldVibrateOnNotification(true);\nB4SSettings.get().setVibrationPattern(new long[]{100, 300, 100, 300});\nB4SSettings.get().setShouldRingOnNotification(true);\nB4SSettings.get().enableNotificationSound();\n\n\n\n\nPush notifications\n\n\nTo use remote push notifications you must first follow the instructions of the \"Base integration\"\n\n\nTo use remote push messaging with the Neerby SDK, ensure that the \nfirebase-messaging\n library is properly specified in your \napp/build.gradle\n dependencies:\n\n\n{\n    implementation 'com.google.firebase:firebase-messaging:17.6.0'\n}\n\n\n\n\n...and init the 'google-services' plugin too :\n\n\n{\n    apply plugin: 'com.google.gms.google-services'\n}\n\n\n\n\nAdd the following class to your project. This class handle events from Firebase Messaging and transmits them to the Neerby SDK.\n\n\npackage x.y.z.myapp;\n\nimport android.app.Activity;\nimport android.content.Context;\n\nimport com.ezeeworld.b4s.android.sdk.B4SLog;\nimport com.ezeeworld.b4s.android.sdk.push.PushApi;\nimport com.google.android.gms.tasks.OnSuccessListener;\nimport com.google.firebase.FirebaseApp;\nimport com.google.firebase.iid.FirebaseInstanceId;\nimport com.google.firebase.iid.InstanceIdResult;\nimport com.google.firebase.messaging.FirebaseMessagingService;\nimport com.google.firebase.messaging.RemoteMessage;\n\npublic class NeerByFirebaseMessagingService extends FirebaseMessagingService {\n    private final static String TAG = \nPushApi\n;\n\n    @Override\n    public void onNewToken(String newToken) {\n        super.onNewToken(newToken);\n\n        PushApi.registerFirebaseToken(newToken);\n    }\n\n    @Override\n    public void onMessageReceived(RemoteMessage remoteMessage) {\n        super.onMessageReceived(remoteMessage);\n\n        PushApi.onMessageReceived(getApplicationContext(), remoteMessage.getData());\n    }\n\n    public static void initFirebase(Activity activity) {\n        try {\n            FirebaseApp.initializeApp(activity);\n        } catch (Exception e) {\n            B4SLog.e(\nPushAPI\n, \nFirebaseApp init failed:\n+e.toString());\n            e.printStackTrace();\n        }\n\n        FirebaseInstanceId.getInstance().getInstanceId().addOnSuccessListener( activity,  new OnSuccessListener\nInstanceIdResult\n() {\n            @Override\n            public void onSuccess(InstanceIdResult instanceIdResult) {\n                String newToken = instanceIdResult.getToken();\n                PushApi.registerFirebaseToken(newToken);\n            }\n        });\n    }\n}\n\n\n\n\nAdd the following declaration in your application AndroidManifest.xml\n\n\nservice\n    android:name=\n.NeerByFirebaseMessagingService\n\n    android:stopWithTask=\nfalse\n\n    android:exported=\nfalse\n\n    \nintent-filter\n\n        \naction android:name=\ncom.google.firebase.MESSAGING_EVENT\n /\n\n    \n/intent-filter\n\n\n/service\n\n\n\n\n\nFinally, add the folowing line to initialize Firebase messaging. Typically, it can be done in your Main Activity class.\n\n\nNeerByFirebaseMessagingService.initFirebase(this);\n\n\n\n\nImportant, do not forget to add your 'google-services.json' in your application source path. You will generate this file from the Firebase console at : https://console.firebase.google.com in Project Overview \nParameters (General tab).\nNext, you will have to record the legacy server key (Cloud Messageing tab) in the Neerby web interface (application settings).\n\n\nDeep linking\n\n\nNotifications such as web links or simple messages are handled directly by the SDK. For deep linking (and deep linking only), there are three options:\n\n\n\n\nDeepLinkStyle.LaunchActivityClearTask\n - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)\n\n\nDeepLinkStyle.LaunchActivityDirect\n - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your \nonNewIntent\n lifecycle method\n\n\nDeepLinkStyle.BroadcastReceiver\n - Deep links are broadcasted with a \ncom.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK\n Intent action type\n\n\n\n\nThe strategy can be set by calling a static method, typically after you have initialized the SDK in your \nApplication\n class:\n\n\n   NotificationService.registerDeepLinkStyle(NotificationService.DeepLinkStyle deepLinkStyle);\n\n\n\n\nWhen you configure to use \nDeepLinkStyle.BroadcastReceiver\n deep links, the application can and must register a \nBroadcastReceiver\n that handles the deep links, such as opening a specific Activity or starting a Service. In your \nAndroidManifest.xml\n you declare:\n\n\n   \nreceiver android:name=\n.DeepLinkReceiver\n\n      \nintent-filter\n\n         \naction android:name=\ncom.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK\n /\n\n      \n/intent-filter\n\n   \n/receiver\n\n\n\n\n\nThe \nDeepLinkReceiver\n can, in its simplest form, simply relay the broadcasts to some other Activity:\n\n\n    public class DeepLinkReceiver extends BroadcastReceiver {\n       @Override\n       public void onReceive(Context context, Intent intent) {\n          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // Required as no Activity context is available\n          context.startActivity(intent);\n       }\n    }\n\n\n\n\nDeep link \nIntent\ns contain a bundle of extras to respond appropriately:\n\n\n\n\nNotificationService.INTENT_SHOW\n - (int) Hash code of the interaction that was matched\n\n\nNotificationService.INTENT_INTERACTIONNAME\n - (String) Name interaction that was matched\n\n\nNotificationService.INTENT_INTERACTION\n - (String) Unique ID of the interaction that was matched\n\n\nNotificationService.INTENT_CAMPAIGN\n - (String) Unique ID of the campaign the matched interaction belongs to\n\n\nNotificationService.INTENT_CAMPAIGNNAME\n - (String) Name of the campaign the matched interaction belongs to\n\n\nNotificationService.INTENT_TITLE\n - (String) Message title, defaults to interaction name if no custom title was supplied\n\n\nNotificationService.INTENT_MESSAGE\n - (String) Message, in which customer name, beacon name, shop name, etc. were already substituted\n\n\nNotificationService.INTENT_SHOPNAME\n - (String) Name of the interaction's shop\n\n\nNotificationService.INTENT_SHOPCLIENTREF\n - (String) The free-form string set on the shop as client reference\n\n\nNotificationService.INTENT_GROUPNAME\n - (String) Name of the interaction's group\n\n\nNotificationService.INTENT_ACTIONID\n - (String) The free-form string with the campaign action id set as deep link reference\n\n\nNotificationService.INTENT_BEACONNAME\n - (String) Name of the matched beacon as configured in the SDK\n\n\nNotificationService.INTENT_BEACONID\n - (IBeaconID) Beacon identification, including technical name (B4S:XXXX:XXXX), UDID, major and minor\n\n\nNotificationService.INTENT_BEACONCLIENTREF\n - (String) The free-form string set on the beacon as client reference\n\n\nNotificationService.INTENT_DISTANCE\n - (double) Distance estimate in meters\n\n\nNotificationService.INTENT_SHOPLATITUDE\n - (double) Latitude of the shop associated to the notification\n\n\nNotificationService.INTENT_SHOPLONGITUDE\n - (double) Longitude of the shop associated to the notification\n\n\nNotificationService.INTENT_TIMESTAMP\n - (double) Timestamp (in seconds) of notification trigger time\n\n\n\n\nDynamic notifications customisation\n\n\nYou have the possibility to let your code modify every notification before they are display to the use.\n\n\nIn order to achieve this, you had to :\n\n\n\n\nAdd the NotificationService.NotificationModifier interface to the class which will be responsible of the notifications customisation.\n\n\nRegister the previous class with \n\n\n\n\n    NotificationService.registerNotificationModifier(this);\n\n\n\n\n\n\nImplements the two methods :\n\n\n\n\npublic String modifyNotificationTitle(Bundle extras) {\n\n}\n\npublic String modifyNotificationMessage(Bundle extras) {\n\n}\n\n\n\n\nThe string returned by these methods will be respectively the modified title and message of the notification. You can even modify the notification properties of the notifications.\n\n\nNotifications customisation using placeholders\n\n\nYou can automatically customise some items displayed within notifications :\n * Notification title\n * Notification text\n * URLs used for deeplink or rich pushes.\n\n\nThis can be achieved by inserting predefined placeholders in the corresponding items. Theses placeholders are :\n\n\n\n\n\n\n\n   This placeholder will be replaced with the name of the beacon which triggered the notification.\n\n\n\n\n\n\n\n   This placeholder will be replaced with the reference code you eventually assigned to the beacon which triggered the notification.\n\n\n\n\n\n\n\n   This placeholder will be replaced with the name of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)\n\n\n\n\n\n\n\n   This placeholder will be replaced with the reference code of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)\n\n\n\n\n\n\n\n   This placeholder will be replaced with the city name of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)\n\n\n\n\n\n\n\n   This placeholder will be replaced with the zip code of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)\n\n\n\n\n\n\n\n   This placeholder will be replaced with the value of the USER_LAST_NAME UserProperty you should have previously set with the following code.\n\n\n\n\n\n\nB4SUserProperty.get().store(B4SUserProperty.USER_LAST_NAME, \nB\u00e9catresse\n);\n\n\n\n\n\n\n\n   This placeholder will be replaced with the value of the USER_FIRST_NAME UserProperty you should have previously set with the following code.\n\n\n\n\nB4SUserProperty.get().store(B4SUserProperty.USER_FIRST_NAME, \nJean-Michel\n);\n\n\n\n\n\n\n\n   This placeholder will be replaced with the value of the USER_CLIENT_REF UserProperty you should have previously set with the following code.\n\n\n\n\nB4SUserProperty.get().store(B4SUserProperty.USER_CLIENT_REF, \nEE123\n);\n\n\n\n\n\n\n\n   This placeholder will be replaced with the timestamp (in seconds ) of the notification generation.\n\n\n\n\nAndroid 6\n\n\nWith Android 6.0 (API level 23) a new permission system was introduced by Google. On Android 6 devices, users can manually manage permissions on a per-application basis. If an app targets Android 6 (using targetSdkVersion 23 and compileSdkVersion 23), an app also needs to deal with runtime permissions. This means that permissions such as location access (which is now a so-called 'dangerous' permission) needs to be explicitly requested with a permission request pop-up. Until SDK version 1.4.2, the B4S SDK does not handle this automatically and therefor the integrator needs to \nhandle permission request dialogs manually\n.\n\n\nFrom version 1.5.0 onwards this will be handled for you by the SDK. A request to access the user location will automatically be shown when access was not yet granted. It is important to note that this affects any application when running on an Android 6 device, even those that still target API level 22 or lower.\n\n\nUsing a transient device UUID\n\n\nWarning\n: using this feature is \nnot\n recommended\n\n\nUpon the app installation, an anymous and persistent device UUID is used if the app is un-installed then re-installed. To make this ID transient add a \nby.neer.sdk.USE_TRANSIENT_DEVICEID\n key to your AndroidManifest.xml, with the value \ntrue\n in the application block.\n\n\nmeta-data android:name=\nby.neer.sdk.USE_TRANSIENT_DEVICEID\n android:value=\ntrue\n /\n\n\n\n\n\nGetting the user's workplace and home coordinates\n\n\nThe SDK tries to determinate the user's home \n workplace coordinate. When accessing those, home and workplace coordinates should be null if the SDK still do not collect enough information to identify the customer home and workplace locations.\n\n\n\nLocation home = B4SSettings.get().userHomeCoordinates();\nif (home != null)\n{\n    // Use the coordinates\n}\nLocation work = B4SSettings.get().userWorkplaceCoordinates();\nif (work != null)\n{\n    // Use the coordinates\n}\n\n\n\n\n\nGetting info about the nearest beacon\n\n\n\nIBeaconData beaconData = SessionManager.get(null).getNearestBeacon();\n// Some properties that can be retrieved\nbeaconData.getDistance();\nbeaconData.getID().getInnerName();\nbeaconData.getID().getUuid();\nbeaconData.getID().getMajor();\nbeaconData.getID().getMinor();", 
            "title": "Using the SDK"
        }, 
        {
            "location": "/using_the_sdk/#base-integration", 
            "text": "Add the  Application ID  provided by Ezeeworld to the  Application  object in you  AndroidManifest.xml . Depending on your project configuration you might have to create this object   application\n   android:name= com.ezeeworld.b4s.android.sdk.sample.SampleApp \n   android:label= @string/app_name   \n   ...\n    meta-data android:name= by.neer.sdk.APP_ID  android:value= MY-APP-ID  / \n    meta-data android:name= by.neer.sdk.AUTOSTART  android:value= true  / \n    meta-data android:name= by.neer.sdk.DISABLE_AUTOMATIC_INIT  android:value= false  / \n   ... /application   And replace  MY-APP-ID  with your unique application ID.  Warning : if these keys are present with a valid application identifier, the SDK will init automatically upon app launch. It will register the device with the Neer.by server (but won't search for beacons, or display notifications, or send geolocalized information to our server). If you want to fully control when the device will be registered to our back-end, set  by.neer.sdk.AUTOSTART  and  by.neer.sdk.DISABLE_AUTOMATIC_INIT  keys to your Manifest, with respectively  false  and  true  value.  xml\n  meta-data android:name=\"by.neer.sdk.AUTOSTART\" android:value=\"false\" / \n  meta-data android:name=\"by.neer.sdk.DISABLE_AUTOMATIC_INIT\" android:value=\"true\" /   Import the SDK in your Application subclass:   import com.ezeeworld.b4s.android.sdk.B4SSettings;   Start the SDK in the  onCreate  method:   B4SSettings settings = B4SSettings.init(this);\nsettings.go();   Finally startup the new geolocation tracking module :   public static LocationAwareThread lat = null;\n\nlat = LocationAwareThread.get();\nif (lat == null) {\n    lat = new LocationAwareThread(getApplicationContext());\n}  Warning : Geolocation is required by the SDK. So you have to request  android.Manifest.permission.ACCESS_FINE_LOCATION  permission before calling B4SSettings.get().go()   On demand SDK activation   There is several way to condition SDK activation :  1) Test location permission to prevent activation before permission are set.  int res = PackageManager.PERMISSION_GRANTED;\nif (Build.VERSION.SDK_INT  = Build.VERSION_CODES.M) {\n  res = getApplicationContext().checkSelfPermission(android.Manifest.permission.ACCESS_FINE_LOCATION);\n}\nLog.d( B4S ,  HabitsApplication init res= +res);\nif (res == PackageManager.PERMISSION_GRANTED) {\n  // Init SDK here\n}  2) Test SharedPreferences value to locally enable SDK :  boolean activateSdk = sharedPreferences.getBoolean(SDK_ACTIVATION, true);\nif (activateSdk) {\n  // Init SDK here\n}", 
            "title": "Base integration"
        }, 
        {
            "location": "/using_the_sdk/#prevent-your-application-to-trigger-notifications-resulting-of-mock-locations", 
            "text": "On Android, some applications (like Lockito) can generate mock locations (typically for debuging purpose). By default, mock locations are authorised by the Neer.by SDK. You can disable them with the following code :  B4SSettings.get().setDiscardMockLocations(true);", 
            "title": "Prevent your application to trigger notifications resulting of mock locations"
        }, 
        {
            "location": "/using_the_sdk/#recording-user-data", 
            "text": "Neerby can relate events to individual customers. Supplying the customer details is typically done on startup and/or after a user signed in to his/her account. In these cases you can update te SDK with this customer data (which is persisted; no need to call this every time). The key should use reverse-dns-like notation to be used as a domain. For instance, the user hometown should use a \"user.hometown\" key. A few keys are provided (Firstname, lastname, gender...)  When the last parameter is set to false, the key/value is uploaded to our server. Uploaded key/values can be used to target users on interactions.  B4SUserProperty.get().store(B4SUserProperty.USER_FIRST_NAME,  Jean-Michel , false);\nB4SUserProperty.get().store(B4SUserProperty.USER_LAST_NAME,  B\u00e9catresse , false);\nB4SUserProperty.get().store(B4SUserProperty.USER_GENDER, B4SUserProperty.Gender.Male, true);\nB4SUserProperty.get().store( user.hometown ,  Tubbydome , true);", 
            "title": "Recording user data"
        }, 
        {
            "location": "/using_the_sdk/#application-tagging", 
            "text": "You can tag your application with the B4S SDK. You have to specify 2 informations :\n\u2022 A tag type\n\u2022 A data dictionnary with the datas associated to your tag.  HashMap String, Object  hmap = new HashMap();\nhmap.put( Key1 ,  String1 );\nhmap.put( Key2 , 123);\nNeerbyTag.newEvent(getApplicationContext(),  UserNavigation , hmap, true);", 
            "title": "Application tagging"
        }, 
        {
            "location": "/using_the_sdk/#custom-notifications", 
            "text": "Icons, icon background colour and vibration can be customised on notifications.  B4SSettings.get().setNotificationBackgroundColor(0xff111111);\nB4SSettings.get().setCustomNotificationSmallIcon(R.drawable.ic_notifsmall);\nB4SSettings.get().setCustomNotificationLargeIcon(R.drawable.ic_notiflarge);\nB4SSettings.get().setShouldVibrateOnNotification(true);\nB4SSettings.get().setVibrationPattern(new long[]{100, 300, 100, 300});\nB4SSettings.get().setShouldRingOnNotification(true);\nB4SSettings.get().enableNotificationSound();", 
            "title": "Custom notifications"
        }, 
        {
            "location": "/using_the_sdk/#push-notifications", 
            "text": "To use remote push notifications you must first follow the instructions of the \"Base integration\"  To use remote push messaging with the Neerby SDK, ensure that the  firebase-messaging  library is properly specified in your  app/build.gradle  dependencies:  {\n    implementation 'com.google.firebase:firebase-messaging:17.6.0'\n}  ...and init the 'google-services' plugin too :  {\n    apply plugin: 'com.google.gms.google-services'\n}  Add the following class to your project. This class handle events from Firebase Messaging and transmits them to the Neerby SDK.  package x.y.z.myapp;\n\nimport android.app.Activity;\nimport android.content.Context;\n\nimport com.ezeeworld.b4s.android.sdk.B4SLog;\nimport com.ezeeworld.b4s.android.sdk.push.PushApi;\nimport com.google.android.gms.tasks.OnSuccessListener;\nimport com.google.firebase.FirebaseApp;\nimport com.google.firebase.iid.FirebaseInstanceId;\nimport com.google.firebase.iid.InstanceIdResult;\nimport com.google.firebase.messaging.FirebaseMessagingService;\nimport com.google.firebase.messaging.RemoteMessage;\n\npublic class NeerByFirebaseMessagingService extends FirebaseMessagingService {\n    private final static String TAG =  PushApi ;\n\n    @Override\n    public void onNewToken(String newToken) {\n        super.onNewToken(newToken);\n\n        PushApi.registerFirebaseToken(newToken);\n    }\n\n    @Override\n    public void onMessageReceived(RemoteMessage remoteMessage) {\n        super.onMessageReceived(remoteMessage);\n\n        PushApi.onMessageReceived(getApplicationContext(), remoteMessage.getData());\n    }\n\n    public static void initFirebase(Activity activity) {\n        try {\n            FirebaseApp.initializeApp(activity);\n        } catch (Exception e) {\n            B4SLog.e( PushAPI ,  FirebaseApp init failed: +e.toString());\n            e.printStackTrace();\n        }\n\n        FirebaseInstanceId.getInstance().getInstanceId().addOnSuccessListener( activity,  new OnSuccessListener InstanceIdResult () {\n            @Override\n            public void onSuccess(InstanceIdResult instanceIdResult) {\n                String newToken = instanceIdResult.getToken();\n                PushApi.registerFirebaseToken(newToken);\n            }\n        });\n    }\n}  Add the following declaration in your application AndroidManifest.xml  service\n    android:name= .NeerByFirebaseMessagingService \n    android:stopWithTask= false \n    android:exported= false \n     intent-filter \n         action android:name= com.google.firebase.MESSAGING_EVENT  / \n     /intent-filter  /service   Finally, add the folowing line to initialize Firebase messaging. Typically, it can be done in your Main Activity class.  NeerByFirebaseMessagingService.initFirebase(this);  Important, do not forget to add your 'google-services.json' in your application source path. You will generate this file from the Firebase console at : https://console.firebase.google.com in Project Overview  Parameters (General tab).\nNext, you will have to record the legacy server key (Cloud Messageing tab) in the Neerby web interface (application settings).", 
            "title": "Push notifications"
        }, 
        {
            "location": "/using_the_sdk/#deep-linking", 
            "text": "Notifications such as web links or simple messages are handled directly by the SDK. For deep linking (and deep linking only), there are three options:   DeepLinkStyle.LaunchActivityClearTask  - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)  DeepLinkStyle.LaunchActivityDirect  - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your  onNewIntent  lifecycle method  DeepLinkStyle.BroadcastReceiver  - Deep links are broadcasted with a  com.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK  Intent action type   The strategy can be set by calling a static method, typically after you have initialized the SDK in your  Application  class:     NotificationService.registerDeepLinkStyle(NotificationService.DeepLinkStyle deepLinkStyle);  When you configure to use  DeepLinkStyle.BroadcastReceiver  deep links, the application can and must register a  BroadcastReceiver  that handles the deep links, such as opening a specific Activity or starting a Service. In your  AndroidManifest.xml  you declare:      receiver android:name= .DeepLinkReceiver \n       intent-filter \n          action android:name= com.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK  / \n       /intent-filter \n    /receiver   The  DeepLinkReceiver  can, in its simplest form, simply relay the broadcasts to some other Activity:      public class DeepLinkReceiver extends BroadcastReceiver {\n       @Override\n       public void onReceive(Context context, Intent intent) {\n          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // Required as no Activity context is available\n          context.startActivity(intent);\n       }\n    }  Deep link  Intent s contain a bundle of extras to respond appropriately:   NotificationService.INTENT_SHOW  - (int) Hash code of the interaction that was matched  NotificationService.INTENT_INTERACTIONNAME  - (String) Name interaction that was matched  NotificationService.INTENT_INTERACTION  - (String) Unique ID of the interaction that was matched  NotificationService.INTENT_CAMPAIGN  - (String) Unique ID of the campaign the matched interaction belongs to  NotificationService.INTENT_CAMPAIGNNAME  - (String) Name of the campaign the matched interaction belongs to  NotificationService.INTENT_TITLE  - (String) Message title, defaults to interaction name if no custom title was supplied  NotificationService.INTENT_MESSAGE  - (String) Message, in which customer name, beacon name, shop name, etc. were already substituted  NotificationService.INTENT_SHOPNAME  - (String) Name of the interaction's shop  NotificationService.INTENT_SHOPCLIENTREF  - (String) The free-form string set on the shop as client reference  NotificationService.INTENT_GROUPNAME  - (String) Name of the interaction's group  NotificationService.INTENT_ACTIONID  - (String) The free-form string with the campaign action id set as deep link reference  NotificationService.INTENT_BEACONNAME  - (String) Name of the matched beacon as configured in the SDK  NotificationService.INTENT_BEACONID  - (IBeaconID) Beacon identification, including technical name (B4S:XXXX:XXXX), UDID, major and minor  NotificationService.INTENT_BEACONCLIENTREF  - (String) The free-form string set on the beacon as client reference  NotificationService.INTENT_DISTANCE  - (double) Distance estimate in meters  NotificationService.INTENT_SHOPLATITUDE  - (double) Latitude of the shop associated to the notification  NotificationService.INTENT_SHOPLONGITUDE  - (double) Longitude of the shop associated to the notification  NotificationService.INTENT_TIMESTAMP  - (double) Timestamp (in seconds) of notification trigger time", 
            "title": "Deep linking"
        }, 
        {
            "location": "/using_the_sdk/#dynamic-notifications-customisation", 
            "text": "You have the possibility to let your code modify every notification before they are display to the use.  In order to achieve this, you had to :   Add the NotificationService.NotificationModifier interface to the class which will be responsible of the notifications customisation.  Register the previous class with        NotificationService.registerNotificationModifier(this);   Implements the two methods :   public String modifyNotificationTitle(Bundle extras) {\n\n}\n\npublic String modifyNotificationMessage(Bundle extras) {\n\n}  The string returned by these methods will be respectively the modified title and message of the notification. You can even modify the notification properties of the notifications.", 
            "title": "Dynamic notifications customisation"
        }, 
        {
            "location": "/using_the_sdk/#notifications-customisation-using-placeholders", 
            "text": "You can automatically customise some items displayed within notifications :\n * Notification title\n * Notification text\n * URLs used for deeplink or rich pushes.  This can be achieved by inserting predefined placeholders in the corresponding items. Theses placeholders are :    \n   This placeholder will be replaced with the name of the beacon which triggered the notification.    \n   This placeholder will be replaced with the reference code you eventually assigned to the beacon which triggered the notification.    \n   This placeholder will be replaced with the name of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)    \n   This placeholder will be replaced with the reference code of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)    \n   This placeholder will be replaced with the city name of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)    \n   This placeholder will be replaced with the zip code of the shop associated to the notification (shop the beacon belongs to or location name of the virtual beacon)    \n   This placeholder will be replaced with the value of the USER_LAST_NAME UserProperty you should have previously set with the following code.    B4SUserProperty.get().store(B4SUserProperty.USER_LAST_NAME,  B\u00e9catresse );   \n   This placeholder will be replaced with the value of the USER_FIRST_NAME UserProperty you should have previously set with the following code.   B4SUserProperty.get().store(B4SUserProperty.USER_FIRST_NAME,  Jean-Michel );   \n   This placeholder will be replaced with the value of the USER_CLIENT_REF UserProperty you should have previously set with the following code.   B4SUserProperty.get().store(B4SUserProperty.USER_CLIENT_REF,  EE123 );   \n   This placeholder will be replaced with the timestamp (in seconds ) of the notification generation.", 
            "title": "Notifications customisation using placeholders"
        }, 
        {
            "location": "/using_the_sdk/#android-6", 
            "text": "With Android 6.0 (API level 23) a new permission system was introduced by Google. On Android 6 devices, users can manually manage permissions on a per-application basis. If an app targets Android 6 (using targetSdkVersion 23 and compileSdkVersion 23), an app also needs to deal with runtime permissions. This means that permissions such as location access (which is now a so-called 'dangerous' permission) needs to be explicitly requested with a permission request pop-up. Until SDK version 1.4.2, the B4S SDK does not handle this automatically and therefor the integrator needs to  handle permission request dialogs manually .  From version 1.5.0 onwards this will be handled for you by the SDK. A request to access the user location will automatically be shown when access was not yet granted. It is important to note that this affects any application when running on an Android 6 device, even those that still target API level 22 or lower.", 
            "title": "Android 6"
        }, 
        {
            "location": "/using_the_sdk/#using-a-transient-device-uuid", 
            "text": "Warning : using this feature is  not  recommended  Upon the app installation, an anymous and persistent device UUID is used if the app is un-installed then re-installed. To make this ID transient add a  by.neer.sdk.USE_TRANSIENT_DEVICEID  key to your AndroidManifest.xml, with the value  true  in the application block.  meta-data android:name= by.neer.sdk.USE_TRANSIENT_DEVICEID  android:value= true  /", 
            "title": "Using a transient device UUID"
        }, 
        {
            "location": "/using_the_sdk/#getting-the-users-workplace-and-home-coordinates", 
            "text": "The SDK tries to determinate the user's home   workplace coordinate. When accessing those, home and workplace coordinates should be null if the SDK still do not collect enough information to identify the customer home and workplace locations.  \nLocation home = B4SSettings.get().userHomeCoordinates();\nif (home != null)\n{\n    // Use the coordinates\n}\nLocation work = B4SSettings.get().userWorkplaceCoordinates();\nif (work != null)\n{\n    // Use the coordinates\n}", 
            "title": "Getting the user's workplace and home coordinates"
        }, 
        {
            "location": "/using_the_sdk/#getting-info-about-the-nearest-beacon", 
            "text": "IBeaconData beaconData = SessionManager.get(null).getNearestBeacon();\n// Some properties that can be retrieved\nbeaconData.getDistance();\nbeaconData.getID().getInnerName();\nbeaconData.getID().getUuid();\nbeaconData.getID().getMajor();\nbeaconData.getID().getMinor();", 
            "title": "Getting info about the nearest beacon"
        }, 
        {
            "location": "/migration_guide/", 
            "text": "Migration guide\n\n\nPlease refer to each individual version step when migrating to a newer SDK. The SDK uses \nSemantic Versioning\n\n\nThe \nIntegration Guide\n always describes the most up-to-date integration requirements.\n\n\nUpgrade to 2.4.5\n\n\nThe old B4STag API is now deprecated. It is replaced with NeerbyTag which is GDPR compliant.\n\n\nUpgrade to 2.4.0\n\n\nNow User properties must be associated with a boolean in order to specify if it has to be sent to our server or not.\n\n\nUpgrade to 2.3.15\n\n\nStarting with 2.3.15, you MUST request GDPR consentement from the application user. If not, the application will only send a minimal data set and will not send notification to the user. Please consult the GDPR page of the documentation.\n\n\nUpgrade to 2.3.12\n\n\nPreviously, the properties by.neer.sdk.AUTOSTART and by.neer.sdk.DISABLE_AUTOMATIC_INIT should be set to manage sdk activation. Starting with 2.3.12 these keys are deprecated and should not be used anymore.\nThe reason is that they can prevent SDK to work flawlessly with Android versions starting with 8.0.\n\n\nUpgrade to 2.3.11\n\n\nNotifications with images support.\nNew location tracking module must be called from the application context as in the sample code :\n  lat = LocationAwareThread.get();\n  if (lat == null) {\n    lat = new LocationAwareThread(getApplicationContext());\n  }\n\n\nUpgrade to 2.3.10\n\n\nAndroid Oreo notificatiion and Beacon detection support.\nSDK initialization changed :\n\u2022 MonitoringManager.ensureMonitoringService() call is no more supported\n\u2022 It is replaced with : B4SSettings.get.go();\n\n\nUpgrade to 2.3.5\n\n\nNotification caping support.\nPlayServices versions prior to 10.2.6 are no more supported since remote push messages causes app crashes for apps build with targetSDK 26 on Android 8.x devices. \n\n\nUpgrade to 2.2.0\n\n\nThe APP-ID should now be set in your application Manifest. The previous installation method is now deprecated. This process is detailed in the installation documentation.\nWe are now using the version 2.2.0 of retrofit.\n\n\nUpgrade to 1.8.4\n\n\nNo changes required.\n\n\nUpgrade to 1.8.3\n\n\nNo code changes required. The minimum SDK level is now set to 10, so applications targeting Android 2.3 can include the library without the need to an \noverrideLibrary\n attribute in their \nuses-sdk /\n manifest declaration.\n\n\nUpgrade to 1.8.2\n\n\nNo changes required.\n\n\nUpgrade to 1.8.1\n\n\nThe deep linking strategy can now optionally be changed. While the default delivery to the launcher Activity in a new task remains unchanged, three strategies are now available:\n\n\n\n\nLaunchActivityClearTask\n - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)\n\n\nLaunchActivityDirect\n - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your \nonNewIntent\n lifecycle method\n\n\nBroadcastReceiver\n - Deep links are broadcasted with a \ncom.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK\n Intent action type\n\n\n\n\nPlease refer to the [[deep linking section|Integration-guide#deep-linking]] in the main integration document for implementation details.\n\n\nUpgrade to 1.8.0\n\n\nA Play Services support library was added in case you want to upgrade to the Play Services 8.4. Just use the \nb4s-android-sdk-playservices840.aar\n  file instead of the existing \nplayservicesXXX\n variant.\n\n\nThe Retrofit dependency was updated to incorporate stability changes and be compatible with apps that still use Retrofit 1.X. Make sure your dependency looks like:\n\n\ndependencies {\n    implementation 'com.squareup.retrofit2:retrofit:2.0.0-beta3'\n    implementation 'com.squareup.retrofit2:converter-jackson:2.0.0-beta3'\n    ...\n}\n\n\n\n\nLocal logging was changed from a level-based to a feature-based distinction. To enable logging, now use the \nB4SSetting.setShouldLogScan(boolean)\n and \nB4SSetting.setShouldLogMatching(boolean)\n methods instead of \nsetShouldLogDebug\n and \nsetShouldLogVerbose\n. Scanning-related logs are reported using the \nB4SSCN\n tag, which campaign matching logs are still using the \nB4S\n tag. For example, to get all logs, use \nadb logcat -s B4SSCN:* B4S:*\n or to only get info and higher priority logs about campaign matching you can use \nadb logcat -s B4S:I\n.\n\n\nUpgrade to 1.7.0\n\n\nThe dependencies were updated for stability and additional functionality. Note that there is now an additional \ncupboard\n dependency. For Eclipse builds, the required jar files can be found in the \n/sample-eclipse/libs\n folder. For Gradle builds, ensure you refer to the correct versions:\n\n\ndependencies {\n    implementation 'nl.qbusict:cupboard:2.1.4'\n    implementation 'de.greenrobot:eventbus:2.4.0'\n    implementation 'com.squareup.retrofit:retrofit:2.0.0-beta2'\n    implementation 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'\n    ...\n}\n\n\n\n\nUpgrade to 1.6.1\n\n\nWhen using the .JAR release with manual declarations in your \nAndroidManifest.xml\n, ensure that the GCM \npermission\n and \nuses-permission\n include your unique package name (instead of the placeholder \nYOUR-PACKAGE-NAME\n):\n\n\n   \npermission\n      android:name=\nYOUR-PACKAGE-NAME\n.permission.C2D_MESSAGE\n\n      android:protectionLevel=\nsignature\n /\n\n   \nuses-permission android:name=\nYOUR-PACKAGE-NAME\n.permission.C2D_MESSAGE\n /\n\n\n\n\n\nThe .AAR version (with Gradle) automatically injects the proper application id in the permission name, starting with this release.\n\n\nUpgrade to 1.6.0\n\n\nThe SDK was split into a core part and a connection part specific to the Play Services library that the application wants to use. This allows, for example, to stay at Play Services 6.5 while still upgrading to the latest B4S version.\n\n\nSecondly, the SDK is now also released in .AAR format, next to the existing .JAR format. When Gradle is used as build system, it is strongly recommended to use the .AAR format as it no longer requires manually declaring B4S services in the Android Manifest.\n\n\nTo upgrade start by removing the B4S services (and activities and broadcast receivers) from your \nAndroidManifest.xml\n. Next, remove the \nb4s-android-sdk.jar\n from your \n/libs\n folder and replace it with the \nb4s-android-sdk.aar\n and  \nb4s-android-sdk-playservicesXXX.aar\n .AAR files from the \n/sdk/aar\n release folder\n. The version of the \n-playservices\n .JAR file should correspond to your Play Services version. For example, use \nb4s-android-sdk-playservices830.jar\n if you are at Play Services 8.3 (v28). Finally, in your root \n/build.gradle\n file, ensure that the libs directory is added to the \nrepositories\n list. This part now looks something like:\n\n\nallprojects {\n    repositories {\n        jcenter()\n        flatDir{\n            dirs 'libs'\n        }\n    }\n}\n\n\n\n\nFinally, in you applications' \napp/build.gradle\n file, add the .AAR file dependencies, For example:\n\n\n    compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices830', ext:'aar')\n\n\n\n\nSee the \nsample-gradle\n sample project\n for an up-to-date configuration which uses Play Services 8.3.\n\n\nUpgrade to 1.5.5\n\n\nThe Google Cloud Messaging (play-services-gcm) dependency is no longer a requirement if (and only if) push messaging is not used.\n\n\nUpgrade to 1.5.4\n\n\nNo changes required.\n\n\nUpgrade to 1.5.2\n\n\nIf multiple B4S apps are installed, the SDK will now automatically choose the most recent SDK version to scan for beacons. This requires additional intent filter definitions for the \nMonitoringManager\n service. Please ensure that it is defined as:\n\n\nservice\nandroid:name=\ncom.ezeeworld.b4s.android.sdk.monitor.MonitoringManager\n\nandroid:exported=\ntrue\n\ntools:ignore=\nExportedService\n\n    \nintent-filter\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_ENSURE_SCANNING\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_SCHEDULE\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_SCHEDULE_RESULT\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_VERSION\n /\n\n        \naction android:name=\ncom.ezeeworld.b4s.android.sdk.monitor.B4S_REPORT_VERSION\n /\n\n    \n/intent-filter\n\n\n/service\n\n\n\n\n\nUpgrade to 1.5.0\n\n\nThe dependencies were updated for better compatibility with recent Play Services and stability. For Eclipse builds, the required jar files can be found in the /sdk/libs folder. For Gradle builds, ensure you refer to the correct versions:\n\n\n   dependencies {\n      implementation 'de.greenrobot:eventbus:2.3.0'\n      implementation 'com.squareup.retrofit:retrofit:2.0.0-beta1'\n      implementation 'com.squareup.retrofit:converter-jackson:2.0.0-beta1'\n      implementation 'com.google.android.gms:play-services-location:8.1.0'\n      implementation 'com.google.android.gms:play-services-ads:8.1.0'\n      implementation \ncom.google.android.gms:play-services-gcm:8.1.0\n\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n   }\n\n\n\n\nIt is no longer necessary (nor should you) to extend from the \nB4SNotificationActivity\n or manage a \nB4SNotificationPopup\n manually. Please remove manual references to these class from your code. Not that, as part of this change, you DO have to supply your \nApplication\n object to the \nB4SSettings.init(Application, String)\n method.\n\n\nThe deep linking intent extra field constants, such as \nINTENT_TITLE\n and \nINTENT_ACTIONID\n, were moved from the \nMonitoringManager\n to the \nNotificationService\n class.\n\n\nThe scanning service was updated for greater speed and reliability, especially on devices with poor Bluetooth hardware. The demo mode (which was exclusively used for testing) is deprecated so the \nB4SSettings.setDemoMode(boolean)\n was removed.\n\n\nOn Android 6.0 a new runtime permission system was introduced, and this is now natively supported. When the user has not (yet) given permissions for the \nandroid.permission-group.LOCATION\n group, the SDK will show a request pop-up. Note that no alerts (pop-ups) will be shown if location services or bluetooth are disabled, although this \nmay now be configured\n.\n\n\nThe \nB4SSettings.storeCustomerFields()\n method was slightly changed, as it is no longer needed to supply a location while a \nuserId\n parameter was added.\n\n\nUpgrade to 1.4.5\n\n\nPush messaging support\n was added, for which a new \nB4SSettings.setPushMessagingSenderId(String)\n method was introduced. As part of the feature, the notification generation was moved and a new service declaration is required:\n\n\n      \nservice\n         android:name=\ncom.ezeeworld.b4s.android.sdk.notifications.NotificationService\n\n         android:exported=\nfalse\n /\n\n\n\n\n\nFor push messaging integration itself, please refer to the \nfull integration document\n.", 
            "title": "Migration guide"
        }, 
        {
            "location": "/migration_guide/#migration-guide", 
            "text": "Please refer to each individual version step when migrating to a newer SDK. The SDK uses  Semantic Versioning  The  Integration Guide  always describes the most up-to-date integration requirements.", 
            "title": "Migration guide"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-245", 
            "text": "The old B4STag API is now deprecated. It is replaced with NeerbyTag which is GDPR compliant.", 
            "title": "Upgrade to 2.4.5"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-240", 
            "text": "Now User properties must be associated with a boolean in order to specify if it has to be sent to our server or not.", 
            "title": "Upgrade to 2.4.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-2315", 
            "text": "Starting with 2.3.15, you MUST request GDPR consentement from the application user. If not, the application will only send a minimal data set and will not send notification to the user. Please consult the GDPR page of the documentation.", 
            "title": "Upgrade to 2.3.15"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-2312", 
            "text": "Previously, the properties by.neer.sdk.AUTOSTART and by.neer.sdk.DISABLE_AUTOMATIC_INIT should be set to manage sdk activation. Starting with 2.3.12 these keys are deprecated and should not be used anymore.\nThe reason is that they can prevent SDK to work flawlessly with Android versions starting with 8.0.", 
            "title": "Upgrade to 2.3.12"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-2311", 
            "text": "Notifications with images support.\nNew location tracking module must be called from the application context as in the sample code :\n  lat = LocationAwareThread.get();\n  if (lat == null) {\n    lat = new LocationAwareThread(getApplicationContext());\n  }", 
            "title": "Upgrade to 2.3.11"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-2310", 
            "text": "Android Oreo notificatiion and Beacon detection support.\nSDK initialization changed :\n\u2022 MonitoringManager.ensureMonitoringService() call is no more supported\n\u2022 It is replaced with : B4SSettings.get.go();", 
            "title": "Upgrade to 2.3.10"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-235", 
            "text": "Notification caping support.\nPlayServices versions prior to 10.2.6 are no more supported since remote push messages causes app crashes for apps build with targetSDK 26 on Android 8.x devices.", 
            "title": "Upgrade to 2.3.5"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-220", 
            "text": "The APP-ID should now be set in your application Manifest. The previous installation method is now deprecated. This process is detailed in the installation documentation.\nWe are now using the version 2.2.0 of retrofit.", 
            "title": "Upgrade to 2.2.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-184", 
            "text": "No changes required.", 
            "title": "Upgrade to 1.8.4"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-183", 
            "text": "No code changes required. The minimum SDK level is now set to 10, so applications targeting Android 2.3 can include the library without the need to an  overrideLibrary  attribute in their  uses-sdk /  manifest declaration.", 
            "title": "Upgrade to 1.8.3"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-182", 
            "text": "No changes required.", 
            "title": "Upgrade to 1.8.2"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-181", 
            "text": "The deep linking strategy can now optionally be changed. While the default delivery to the launcher Activity in a new task remains unchanged, three strategies are now available:   LaunchActivityClearTask  - (Default) Deep links are delivered to your launch Activity, and always in a new task (with an Activity restart)  LaunchActivityDirect  - Deep links are delivered to your launch Activity; if this is already running the Intent is delivered directly to your  onNewIntent  lifecycle method  BroadcastReceiver  - Deep links are broadcasted with a  com.ezeeworld.b4s.android.sdk.notifications.DEEP_LINK  Intent action type   Please refer to the [[deep linking section|Integration-guide#deep-linking]] in the main integration document for implementation details.", 
            "title": "Upgrade to 1.8.1"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-180", 
            "text": "A Play Services support library was added in case you want to upgrade to the Play Services 8.4. Just use the  b4s-android-sdk-playservices840.aar   file instead of the existing  playservicesXXX  variant.  The Retrofit dependency was updated to incorporate stability changes and be compatible with apps that still use Retrofit 1.X. Make sure your dependency looks like:  dependencies {\n    implementation 'com.squareup.retrofit2:retrofit:2.0.0-beta3'\n    implementation 'com.squareup.retrofit2:converter-jackson:2.0.0-beta3'\n    ...\n}  Local logging was changed from a level-based to a feature-based distinction. To enable logging, now use the  B4SSetting.setShouldLogScan(boolean)  and  B4SSetting.setShouldLogMatching(boolean)  methods instead of  setShouldLogDebug  and  setShouldLogVerbose . Scanning-related logs are reported using the  B4SSCN  tag, which campaign matching logs are still using the  B4S  tag. For example, to get all logs, use  adb logcat -s B4SSCN:* B4S:*  or to only get info and higher priority logs about campaign matching you can use  adb logcat -s B4S:I .", 
            "title": "Upgrade to 1.8.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-170", 
            "text": "The dependencies were updated for stability and additional functionality. Note that there is now an additional  cupboard  dependency. For Eclipse builds, the required jar files can be found in the  /sample-eclipse/libs  folder. For Gradle builds, ensure you refer to the correct versions:  dependencies {\n    implementation 'nl.qbusict:cupboard:2.1.4'\n    implementation 'de.greenrobot:eventbus:2.4.0'\n    implementation 'com.squareup.retrofit:retrofit:2.0.0-beta2'\n    implementation 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'\n    ...\n}", 
            "title": "Upgrade to 1.7.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-161", 
            "text": "When using the .JAR release with manual declarations in your  AndroidManifest.xml , ensure that the GCM  permission  and  uses-permission  include your unique package name (instead of the placeholder  YOUR-PACKAGE-NAME ):      permission\n      android:name= YOUR-PACKAGE-NAME .permission.C2D_MESSAGE \n      android:protectionLevel= signature  / \n    uses-permission android:name= YOUR-PACKAGE-NAME .permission.C2D_MESSAGE  /   The .AAR version (with Gradle) automatically injects the proper application id in the permission name, starting with this release.", 
            "title": "Upgrade to 1.6.1"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-160", 
            "text": "The SDK was split into a core part and a connection part specific to the Play Services library that the application wants to use. This allows, for example, to stay at Play Services 6.5 while still upgrading to the latest B4S version.  Secondly, the SDK is now also released in .AAR format, next to the existing .JAR format. When Gradle is used as build system, it is strongly recommended to use the .AAR format as it no longer requires manually declaring B4S services in the Android Manifest.  To upgrade start by removing the B4S services (and activities and broadcast receivers) from your  AndroidManifest.xml . Next, remove the  b4s-android-sdk.jar  from your  /libs  folder and replace it with the  b4s-android-sdk.aar  and   b4s-android-sdk-playservicesXXX.aar  .AAR files from the  /sdk/aar  release folder . The version of the  -playservices  .JAR file should correspond to your Play Services version. For example, use  b4s-android-sdk-playservices830.jar  if you are at Play Services 8.3 (v28). Finally, in your root  /build.gradle  file, ensure that the libs directory is added to the  repositories  list. This part now looks something like:  allprojects {\n    repositories {\n        jcenter()\n        flatDir{\n            dirs 'libs'\n        }\n    }\n}  Finally, in you applications'  app/build.gradle  file, add the .AAR file dependencies, For example:      compile (name:'b4s-android-sdk', ext:'aar')\n    compile (name:'b4s-android-sdk-playservices830', ext:'aar')  See the  sample-gradle  sample project  for an up-to-date configuration which uses Play Services 8.3.", 
            "title": "Upgrade to 1.6.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-155", 
            "text": "The Google Cloud Messaging (play-services-gcm) dependency is no longer a requirement if (and only if) push messaging is not used.", 
            "title": "Upgrade to 1.5.5"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-154", 
            "text": "No changes required.", 
            "title": "Upgrade to 1.5.4"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-152", 
            "text": "If multiple B4S apps are installed, the SDK will now automatically choose the most recent SDK version to scan for beacons. This requires additional intent filter definitions for the  MonitoringManager  service. Please ensure that it is defined as:  service\nandroid:name= com.ezeeworld.b4s.android.sdk.monitor.MonitoringManager \nandroid:exported= true \ntools:ignore= ExportedService \n     intent-filter \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_ENSURE_SCANNING  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_SCHEDULE  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_SCHEDULE_RESULT  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_QUERY_VERSION  / \n         action android:name= com.ezeeworld.b4s.android.sdk.monitor.B4S_REPORT_VERSION  / \n     /intent-filter  /service", 
            "title": "Upgrade to 1.5.2"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-150", 
            "text": "The dependencies were updated for better compatibility with recent Play Services and stability. For Eclipse builds, the required jar files can be found in the /sdk/libs folder. For Gradle builds, ensure you refer to the correct versions:     dependencies {\n      implementation 'de.greenrobot:eventbus:2.3.0'\n      implementation 'com.squareup.retrofit:retrofit:2.0.0-beta1'\n      implementation 'com.squareup.retrofit:converter-jackson:2.0.0-beta1'\n      implementation 'com.google.android.gms:play-services-location:8.1.0'\n      implementation 'com.google.android.gms:play-services-ads:8.1.0'\n      implementation  com.google.android.gms:play-services-gcm:8.1.0 \n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n   }  It is no longer necessary (nor should you) to extend from the  B4SNotificationActivity  or manage a  B4SNotificationPopup  manually. Please remove manual references to these class from your code. Not that, as part of this change, you DO have to supply your  Application  object to the  B4SSettings.init(Application, String)  method.  The deep linking intent extra field constants, such as  INTENT_TITLE  and  INTENT_ACTIONID , were moved from the  MonitoringManager  to the  NotificationService  class.  The scanning service was updated for greater speed and reliability, especially on devices with poor Bluetooth hardware. The demo mode (which was exclusively used for testing) is deprecated so the  B4SSettings.setDemoMode(boolean)  was removed.  On Android 6.0 a new runtime permission system was introduced, and this is now natively supported. When the user has not (yet) given permissions for the  android.permission-group.LOCATION  group, the SDK will show a request pop-up. Note that no alerts (pop-ups) will be shown if location services or bluetooth are disabled, although this  may now be configured .  The  B4SSettings.storeCustomerFields()  method was slightly changed, as it is no longer needed to supply a location while a  userId  parameter was added.", 
            "title": "Upgrade to 1.5.0"
        }, 
        {
            "location": "/migration_guide/#upgrade-to-145", 
            "text": "Push messaging support  was added, for which a new  B4SSettings.setPushMessagingSenderId(String)  method was introduced. As part of the feature, the notification generation was moved and a new service declaration is required:         service\n         android:name= com.ezeeworld.b4s.android.sdk.notifications.NotificationService \n         android:exported= false  /   For push messaging integration itself, please refer to the  full integration document .", 
            "title": "Upgrade to 1.4.5"
        }, 
        {
            "location": "/gdpr_compliance/", 
            "text": "GDPR Compliance\n\n\nThe Neerby SDK allows compliance with the GDPR regulation. The end user must give his explicit permission to the app to collect data \n store data.\n\n\nDepending on the terms of your contract with Ezeeworld, one or multiple \npurposes\n are created and attached to your application. Each purpose is defined by a name (e.g \ntech.purpose.purpose_name\n) and a retention period for each data type (sessions, user properties, stop locations, ATR data). \n\n\nEnabling a purpose\n\n\nTo enable a purpose the app must asks the user (using a modal dialog, a setting panel....) and call the following method:\n\n\nB4SSettings.get().setPurposeStatus(\ntech.purpose.purpose_name\n, TRUE);\n\n\n\n\n\nDisabling a purpose\n\n\nTo enable a purpose the app must asks the user (using a modal dialog, a setting panel....) and call the following method:\n\n\nB4SSettings.get().setPurposeStatus(\ntech.purpose.purpose_name\n, FALSE);\n\n\n\n\n\nGetting a purpose status\n\n\nTo get the status of a purpose:\n\n\nB4SSettings.get().getPurposeStatus(\ntech.purpose.purpose_name\n);", 
            "title": "GDPR Compliance"
        }, 
        {
            "location": "/gdpr_compliance/#gdpr-compliance", 
            "text": "The Neerby SDK allows compliance with the GDPR regulation. The end user must give his explicit permission to the app to collect data   store data.  Depending on the terms of your contract with Ezeeworld, one or multiple  purposes  are created and attached to your application. Each purpose is defined by a name (e.g  tech.purpose.purpose_name ) and a retention period for each data type (sessions, user properties, stop locations, ATR data).", 
            "title": "GDPR Compliance"
        }, 
        {
            "location": "/gdpr_compliance/#enabling-a-purpose", 
            "text": "To enable a purpose the app must asks the user (using a modal dialog, a setting panel....) and call the following method:  B4SSettings.get().setPurposeStatus( tech.purpose.purpose_name , TRUE);", 
            "title": "Enabling a purpose"
        }, 
        {
            "location": "/gdpr_compliance/#disabling-a-purpose", 
            "text": "To enable a purpose the app must asks the user (using a modal dialog, a setting panel....) and call the following method:  B4SSettings.get().setPurposeStatus( tech.purpose.purpose_name , FALSE);", 
            "title": "Disabling a purpose"
        }, 
        {
            "location": "/gdpr_compliance/#getting-a-purpose-status", 
            "text": "To get the status of a purpose:  B4SSettings.get().getPurposeStatus( tech.purpose.purpose_name );", 
            "title": "Getting a purpose status"
        }
    ]
}